<!DOCTYPE html><html lang="en"><script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><script src="/live2d-widget/autoload.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="/tipuesearch/tipuesearch_content.js"></script><link rel="stylesheet" href="/tipuesearch/tipuesearch.css"><script src="/tipuesearch/tipuesearch_set.js"></script><script src="/tipuesearch/tipuesearch.min.js"></script><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>cas深入理解 | MaoZH</title><script src="https://cdn.bootcss.com/valine/1.4.4/Valine.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/mermaid/8.11.0/mermaid.min.js"></script><script>mermaid.initialize({
  startOnLoad: true
  , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="MaoZH" type="application/atom+xml">
</head><body><header><nav><a href="/">Home</a><a href="/archives/">Archives</a><a href="/resources/">Resources</a></nav></header><main><article><div id="post-bg"><div id="post-title"><h1>cas深入理解</h1><hr></div><div id="post-content"><h3 id="一、CAS概述"><a href="#一、CAS概述" class="headerlink" title="一、CAS概述"></a>一、CAS概述</h3><p>CAS （compareAndSwap），是一种无锁原子算法，也就是映射到操作系统就是一条CPU指令，是原子操作。其实现方式是基于硬件平台的汇编指令，在intel的CPU中，使用的是cmpxchg指令，就是说CAS是靠硬件实现的，从而在硬件层面提高效率。</p>
<span id="more"></span>

<p>当多个线程同时使用CAS 操做一个变量时，最多只有一个会胜出，并成功更新，其他均会失败。失败的线程不会挂起，仅是被告知失败，而且容许再次尝试（自旋），固然也容许实现的线程放弃操做。基于这样的原理，CAS 操做即便没有锁，也能够避免其余线程对当前线程的干扰。</p>
<h3 id="二、底层实现"><a href="#二、底层实现" class="headerlink" title="二、底层实现"></a>二、底层实现</h3><p>其实，CAS操作原本就是两个原子操作的，但是归功于硬件指令集的发展，让硬件保证这个从语义上看起来需要屡次操作的CAS行为只经过一条处理器指令就能完成(原子指令的定义)。常见的原子指令有：</p>
<ul>
<li>测试并设置（Tetst-and-Set）</li>
<li>获取并增长（Fetch-and-Increment）</li>
<li>比较并交换（Compare-and-Swap）</li>
<li>加载连接/条件存储（Load-Linked/Store-Conditional）</li>
</ul>
<h4 id="CPU实现原子指令的方式"><a href="#CPU实现原子指令的方式" class="headerlink" title="CPU实现原子指令的方式"></a>CPU实现原子指令的方式</h4><p><strong>总线锁定</strong></p>
<p>总线锁定就是处理器使用了总线锁，总线锁就是使用处理器提供的一个 LOCK# 信号，当处理器操作共享变量，在BUS总线上发出一个LOCK信号，其它的处理器的请求将会被阻塞，该处理器能够独占共享内存。总线锁定在阻塞其它处理器获取该共享变量的操作请求时，也可能会导致大量阻塞，从而增加系统的性能开销。</p>
<p><strong>缓存锁定</strong></p>
<p>缓存锁定是指变量缓存在处理器的缓存行当中，LOCK期间操作锁定，当该处理器对缓存中的共享变量进行了操作，其他处理器会有个嗅探机制，阻止同时修改两个以上处理器缓存的内存区域数据，当其余处理器回写已被锁定的缓存行的数据时，会使缓存行无效。待其他线程读取时会重新从主内存中读取最新的数据，基于 MESI 缓存一致性协议来实现的。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/563436e974a0">https://www.jianshu.com/p/563436e974a0</a></p>
<p>两种情况下处理器不能使用缓存锁定：</p>
<p>1.当操作的数据不能被缓存在处理器内部或者操作的数据跨越多个缓存行时，处理器会调用总线锁定</p>
<p>2.一些处理器不支持</p>
<p>CAS是由Unsafe类实现的，Java没法直接访问底层操做系统，而是经过本地（native）方法来访问，因此启用了一个Unsafe类进行硬件级别的原子操作。</p>
<p>以AtomicInteger 类调用incrementAndGet（）方法实现原子性的自增为例：</p>
<p><img src="/2022/01/01/cas%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211211224814027.png" alt="image-20211211224814027"></p>
<p>在Unsafe类的getAndAddInt方法中主要是看compareAndSwapInt方法：</p>
<p><img src="/2022/01/01/cas%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211211224922595.png" alt="image-20211211224922595"></p>
<p><img src="/2022/01/01/cas%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211211225043084.png" alt="image-20211211225043084"></p>
<p>可见Unsafe类中的compareAndSwapInt是一个native本地方法</p>
<p>具体实现的虚拟机（HotSpot）中去查看C++源码：</p>
<p><img src="/2022/01/01/cas%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/35a76fe5e3984ff396c671343623d1c7-1.jpg" alt="img"></p>
<p>查看Atomic::cmpxchg函数的具体实现，这个本地方法的最终实现在openjdk的如下位置：openjdk-7-fcs-src-b147-27<em>jun</em>2011\openjdk\hotspot\src\os<em>cpu\windows</em>x86\vm\ atomic<em>windows</em>x86.inline.hpp（对应于windows操作系统，X86处理器）。下面是对应于intel x86处理器的源代码的片段，asm是C++中的一个关键字,用于在C++源码中内嵌汇编语言</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Adding a lock prefix to an instruction on MP machine</span><br><span class="hljs-comment">// VC++ doesn&#x27;t like the lock prefix to be on a single line</span><br><span class="hljs-comment">// so we can&#x27;t insert a label after the lock prefix.</span><br><span class="hljs-comment">// By emitting a lock prefix, we can define a label after it.</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOCK_IF_MP(mp) __asm cmp mp, 0  \</span><br><span class="hljs-meta">                       __asm je L0      \</span><br><span class="hljs-meta">                       __asm _emit 0xF0 \</span><br><span class="hljs-meta">                       __asm L0:</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> jint     <span class="hljs-title">Atomic::cmpxchg</span>    <span class="hljs-params">(jint     exchange_value, <span class="hljs-keyword">volatile</span> jint*     dest, jint     compare_value)</span> </span>&#123;<br>  <span class="hljs-comment">// alternative for InterlockedCompareExchange</span><br>  <span class="hljs-keyword">int</span> mp = os::<span class="hljs-built_in">is_MP</span>();<br>  __asm &#123;<br>    mov edx, dest<br>    mov ecx, exchange_value<br>    mov eax, <span class="hljs-function">compare_value</span><br><span class="hljs-function">    <span class="hljs-title">LOCK_IF_MP</span><span class="hljs-params">(mp)</span><span class="hljs-comment">//根据cpu类型加锁</span></span><br><span class="hljs-function">    cmpxchg dword ptr [edx], ecx<span class="hljs-comment">//原子指令</span></span><br><span class="hljs-function">  &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p><img src="/2022/01/01/cas%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/35799c6ec02c4168826c67f946496405-1-1639234657784.jpg" alt="img"></p>
<p>可见最后这个cmpxchg是单条操作指令，这条汇编语言能够直接操做内存进行数据交换，实现CAS最终目的。</p>
<p>可以看到这里有一个LOCK_IF_MP，作用是若是多处理器，在指令前加上LOCK前缀，由于在单处理器中，是不会存在缓存不一致的问题的，全部线程都在一个CPU上跑，使用同一个缓存区，也就不存在缓存与主内存不一致的问题，不会形成可见性问题。</p>
<p>（缓存在CPU上，主内存不在CPU上，CPU是经过缓存去读取主内存的，每一个CPU对应一个缓存，不一样缓存对应不一样CPU，这里要结合前面的JMM模型和硬件架构理一理）</p>
<p>然而在多核处理器中，须要遵循<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wewill/p/8098189.html#mesi">缓存一致性协议</a>通知其余处理器更新本身的缓存。</p>
<p>Lock在这里的做用：</p>
<ul>
<li>在cmpxchg执行期间，锁住内存地址[edx]，其余处理器不能访问该内存，保证原子性。</li>
</ul>
<p>（这个就是保证CAS原子性的关键所在）</p>
<ul>
<li>写内存屏障，保证每一个线程的本地空间与主存一致。</li>
<li>禁止cmpxchg与先后任何指令重排序，防止指令重排序。</li>
</ul>
<p><img src="/2022/01/01/cas%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/9f1f8241116b42dd89999c3e3c264633-1.jpg" alt="img"></p>
<p><strong>CAS缺点</strong></p>
<p>CAS虽然高效地解决了原子操作，可是仍是存在一些缺陷的，主要表如今三个方面：</p>
<p>1.自旋时间太长</p>
<p>若是CAS一直不成功呢？这种状况绝对有可能发生，若是自旋CAS长时间地不成功，则会给CPU带来很是大的开销。在JUC中有些地方就限制了CAS自旋的次数，例如BlockingQueue的SynchronousQueue。</p>
<p>2.只能保证一个共享变量原子操做</p>
<p>看了CAS的实现就知道这只能针对一个共享变量，若是是多个共享变量就只能使用锁了，固然若是你有办法把多个变量整成一个变量，利用CAS也不错。例如读写锁中state的高低位。（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wait-pigblog/p/9350569.html%EF%BC%89">https://www.cnblogs.com/wait-pigblog/p/9350569.html）</a></p>
<p>3.ABA问题</p>
<p>CAS须要检查操做值有没有发生改变，若是没有发生改变则更新。可是存在这样一种状况：若是一个值原来是A，变成了B，而后又变成了A，那么在CAS检查的时候会发现没有改变，可是实质上它已经发生了改变，只是又回到了原来的值而已，这就是所谓的ABA问题。对于ABA问题其解决方案是加上版本号，即在每一个变量都加上一个版本号，每次改变时加1，即A —&gt; B —&gt; A，变成1A —&gt; 2B —&gt; 3A，采用AtomicStampedRdference类能够实现这个方案。</p>
<h3 id="1-入门实例"><a href="#1-入门实例" class="headerlink" title="1.入门实例"></a>1.入门实例</h3><p>基于无锁解决取款并发问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test5</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Account account = <span class="hljs-keyword">new</span> AccountCas(<span class="hljs-number">10000</span>);<br>        Account.demo(account);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span></span>&#123;<br>    <span class="hljs-keyword">private</span> AtomicInteger balance;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountCas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> balance)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicInteger(balance);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> balance.get();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-comment">//1.获取余额最新值</span><br>            <span class="hljs-keyword">int</span> prev = balance.get();<br>            <span class="hljs-comment">//2.减去取款金额</span><br>            <span class="hljs-keyword">int</span> next = prev - amount;<br>            <span class="hljs-comment">//3.真正修改余额</span><br>            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-comment">// 获取余额</span><br>    <span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 取款</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span></span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span><br><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Account account)</span> </span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                account.withdraw(<span class="hljs-number">10</span>);<br>            &#125;));<br>        &#125;<br>        ts.forEach(Thread::start);<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<br>        System.out.println(account.getBalance()<br>                + <span class="hljs-string">&quot; cost: &quot;</span> + (end-start)/<span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>小结</strong> ：其实这里并不是无锁，而是使用了乐观锁。</p>
<p>线程的最新值与线程工作内存中的值进行比较，如果相等为true则修改为最新值，反之不修改</p>
<p><img src="/2022/01/01/cas%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211018221825808.png" alt="image-20211018221825808"></p>
<ul>
<li>CAS底层实现是由CPU硬件实现的：是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</li>
<li>CAS必须借助volatile才能读取到共享变量的<strong>最新值</strong>来实现比较并交换操作的效果</li>
</ul>
<p><strong>思考</strong> ：无锁(乐观锁)的效率为何要更高些？</p>
<p>1.即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。</p>
<p>2.需要注意的是，在无所情况下，需要额外多余CPU的支持，如果CPU不够会由于分不到时间片仍然进入到就绪状态，依然会导致上下文切换。</p>
<p><strong>小结</strong> ：结合CAS和volatile可以实现无锁并发，适用于线程数少，多核CPU的场景<br>a.CAS是基于乐观锁的思想，不怕其他的线程修改共享变量，在需要使用时再去考虑是否发生变化满足一致性<br>b.Synchronized是基于悲观锁的思想，以最悲观的打算防止其他线程修改共享变量，等到自己释放锁其他线程才能有机会修改共享变量。<br>c.CAS体现的是无锁并发(不需要加锁来保证线程安全)，无阻塞并发(保持线程不断运行，不发生上下文切换)；总之线程不会因为加锁使得进入阻塞状态，但如果竞争激烈时可以频繁重试，此时反而会影响效率。</p>
<h3 id="2-原子类"><a href="#2-原子类" class="headerlink" title="2.原子类"></a>2.原子类</h3><h4 id="2-1原子整数"><a href="#2-1原子整数" class="headerlink" title="2.1原子整数"></a>2.1原子整数</h4><p>JUC并发包下的工具类：</p>
<p>AtomicBoolean<br>AtomicInteger<br>AtomicLong</p>
<p>对常用的类型进行封装，使得对其操作满足原子性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test6</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//保证了操作的原子性，不会被打断</span><br>        System.out.println(i.incrementAndGet());<span class="hljs-comment">// ++i</span><br>        System.out.println(i.getAndIncrement());<span class="hljs-comment">//i++</span><br>        System.out.println(i.getAndAdd(<span class="hljs-number">3</span>));<span class="hljs-comment">//先获取值2再加3，因此这里输出为2</span><br>        i.updateAndGet(value -&gt; value * <span class="hljs-number">12</span>);<span class="hljs-comment">//取得当前的i值按照括号内的规则进行操作</span><br>        System.out.println(i.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//updateAndGet的底层实现也是使用CAS</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateAndGet</span><span class="hljs-params">(IntUnaryOperator updateFunction)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> prev, next;<br>    <span class="hljs-keyword">do</span> &#123;<br>        prev = get();<br>        next = updateFunction.applyAsInt(prev);<br>    &#125; <span class="hljs-keyword">while</span> (!compareAndSet(prev, next));<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-2原子引用"><a href="#2-2原子引用" class="headerlink" title="2.2原子引用"></a>2.2原子引用</h4><p>由于有时需要保证一些非基本类型的原子操作，因此需要原子引用类型<br>AtomicReference<br>AtomicMarkableReference<br>AtomicStampedReference</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        DecimalAccount.demo(<span class="hljs-keyword">new</span> DecimalAccountCas(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;10000&quot;</span>)));<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecimalAccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DecimalAccount</span></span>&#123;<br>    <span class="hljs-keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecimalAccountCas</span><span class="hljs-params">(BigDecimal balance)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(balance);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> balance.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            BigDecimal prev = balance.get();<br>            BigDecimal next = prev.subtract(amount);<br>            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br>    <span class="hljs-comment">// 获取余额</span><br>    <span class="hljs-function">BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 取款</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span></span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span><br><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(DecimalAccount account)</span> </span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                account.withdraw(BigDecimal.TEN);<br>            &#125;));<br>        &#125;<br>        ts.forEach(Thread::start);<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        System.out.println(account.getBalance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>可见其基本用法其实和原子整数差不多，都是以CAS为基础的。</li>
</ul>
<h4 id="2-3ABA问题"><a href="#2-3ABA问题" class="headerlink" title="2.3ABA问题"></a>2.3ABA问题</h4><p>将一个值改变后又改回去，CAS发现不了这个过程，如果是基本类型无影响，但是对于引用类型产生影响，解决方法就是加上版本信息</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test8</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">&quot;old&quot;</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        String prev = ref.get();<br>        f();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        System.out.println(ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;new&quot;</span>));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;change old -&gt; new:&quot;</span> + ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;new&quot;</span>));<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;change new -&gt; old:&quot;</span> + ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;old&quot;</span>));<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>加上版本号</strong>(AtomicStampedReference)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test9</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-string">&quot;old&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//获取值</span><br>        String prev = ref.getReference();<br>        <span class="hljs-comment">//获取版本号</span><br>        <span class="hljs-keyword">int</span> stamp = ref.getStamp();<br>        System.out.println(<span class="hljs-string">&quot;此时版本号为&quot;</span>+ stamp);<br>        f();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        System.out.println(ref.compareAndSet(prev, <span class="hljs-string">&quot;new&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">int</span> stamp = ref.getStamp();<br>            System.out.println(<span class="hljs-string">&quot;change old -&gt; new:&quot;</span> + ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;new&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">int</span> stamp = ref.getStamp();<br>            System.out.println(<span class="hljs-string">&quot;change new -&gt; old:&quot;</span> + ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;old&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>AtomicMarkableReference</strong> </p>
<p>有时候并不关心引用变量更改了几次，只是单纯的关心是否更改过，此时就应该使用 AtomicMarkableReference</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test10</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        GarbageBag bag = <span class="hljs-keyword">new</span> GarbageBag(<span class="hljs-string">&quot;已满&quot;</span>);<br>        AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(bag, <span class="hljs-keyword">true</span>);<br>        System.out.println(<span class="hljs-string">&quot;main线程开始...&quot;</span>);<br>        GarbageBag prev = ref.getReference();<br>        System.out.println(prev.toString());<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;打扫卫生线程开始...&quot;</span>);<br>            bag.setDesc(<span class="hljs-string">&quot;空垃圾袋&quot;</span>);<br>            <span class="hljs-keyword">while</span> (!ref.compareAndSet(bag, bag, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>))&#123;&#125;<br>            System.out.println(bag.toString());<br>        &#125;, <span class="hljs-string">&quot;清洁工&quot;</span>).start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-string">&quot;main线程想换新垃圾袋!!&quot;</span>);<br>        <span class="hljs-keyword">boolean</span> success = ref.compareAndSet(prev, <span class="hljs-keyword">new</span> GarbageBag(<span class="hljs-string">&quot;空垃圾袋&quot;</span>), <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>        System.out.println(<span class="hljs-string">&quot;换成功了吗?&quot;</span> + success);<br>        System.out.println(ref.getReference().toString());<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GarbageBag</span> </span>&#123;<br>    String desc;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GarbageBag</span><span class="hljs-params">(String desc)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.desc = desc;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDesc</span><span class="hljs-params">(String desc)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.desc = desc;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.toString() + <span class="hljs-string">&quot; &quot;</span> + desc;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>注意清洁工线程没有更换垃圾袋，而是将其清空并修改了垃圾袋状态，因此最后主线程无法成功更换，而且最终垃圾袋也没有变过。</li>
</ul>
<h4 id="2-4原子数组"><a href="#2-4原子数组" class="headerlink" title="2.4原子数组"></a>2.4原子数组</h4><p>AtomicIntegerArray   AtomicLongArray   AtomicReferenceArray</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test11</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        demo(<br>                () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>],<br>                (array) -&gt; array.length,<br>                (array, index) -&gt; array[index] ++,<br>                array -&gt; System.out.println(Arrays.toString(array))<br>        );<br>        demo(<br>                () -&gt; <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-number">10</span>),<br>                (array) -&gt; array.length(),<br>                (array, index) -&gt; array.getAndIncrement(index),<br>                array -&gt; System.out.println(array)<br>        );<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     参数1，提供数组、可以是线程不安全数组或线程安全数组</span><br><span class="hljs-comment">     参数2，获取数组长度的方法</span><br><span class="hljs-comment">     参数3，自增方法，回传 array, index</span><br><span class="hljs-comment">     参数4，打印数组的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//supplier提供者，无中生有 ()-&gt;结果</span><br>    <span class="hljs-comment">//function函数 一个参数一个结果 (参数)-&gt;结果 ；  BiFunction  (参数1, 参数2) -&gt; 结果</span><br>    <span class="hljs-comment">//consumer消费者 一个参数没有结果 (参数)-&gt;void  ;  BiConsumer  (参数1, 参数2) -&gt; void</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            Supplier&lt;T&gt; arraySupplier,</span></span><br><span class="hljs-params"><span class="hljs-function">            Function&lt;T, Integer&gt; lengthFun,</span></span><br><span class="hljs-params"><span class="hljs-function">            BiConsumer&lt;T, Integer&gt; putConsumer,</span></span><br><span class="hljs-params"><span class="hljs-function">            Consumer&lt;T&gt; printConsumer</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        T array = arraySupplier.get();<br>        <span class="hljs-keyword">int</span> length = lengthFun.apply(array);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i ++) &#123;<br>            <span class="hljs-comment">//每个线程对数组作10000次操作</span><br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    putConsumer.accept(array, j % length);<br>                &#125;<br>            &#125;));<br>        &#125;<br>        ts.forEach(t -&gt; t.start());<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                t.join();<br>            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        printConsumer.accept(array);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br>[<span class="hljs-number">8309</span>, <span class="hljs-number">8293</span>, <span class="hljs-number">8319</span>, <span class="hljs-number">8296</span>, <span class="hljs-number">8292</span>, <span class="hljs-number">8344</span>, <span class="hljs-number">8323</span>, <span class="hljs-number">8312</span>, <span class="hljs-number">8335</span>, <span class="hljs-number">8309</span>]<br>[<span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>]<br></code></pre></td></tr></table></figure>

<p>可见原子数组可以保证数组当中各元素在多个线程访问时依然保持线程安全性。</p>
<h4 id="2-5字段更新器"><a href="#2-5字段更新器" class="headerlink" title="2.5字段更新器"></a>2.5字段更新器</h4><p>对某个对象的属性或者成员变量进行保护，满足线程安全性。</p>
<p>AtomicReferenceFieldUpdater // 域 字段<br>AtomicIntegerFieldUpdater<br>AtomicLongFieldUpdater</p>
<p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test12</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student stu = <span class="hljs-keyword">new</span> Student();<br>        <span class="hljs-comment">//三个参数为：对象的类；修改字段的类型；修改的字段的名称</span><br>        AtomicReferenceFieldUpdater updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="hljs-string">&quot;name&quot;</span>);<br>        updater.compareAndSet(stu, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;小明&quot;</span>);<br>        System.out.println(stu.toString());<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">volatile</span> String name;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个API的使用需要注意参数，对于对象的属性在多线程情况下进行保护。</p>
<h4 id="2-6原子累加器"><a href="#2-6原子累加器" class="headerlink" title="2.6原子累加器"></a>2.6原子累加器</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test13</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> cnt  = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(() -&gt; <span class="hljs-keyword">new</span> LongAdder(), adder -&gt; adder.increment());<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(() -&gt; <span class="hljs-keyword">new</span> AtomicLong(), adder -&gt; adder.getAndIncrement());<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            Object o = <span class="hljs-keyword">new</span> Object();<br>            <span class="hljs-keyword">long</span> start = System.nanoTime();<br>            List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">40</span>; j++) &#123;<br>                ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>                        <span class="hljs-comment">//锁住的是同一对象</span><br>                        <span class="hljs-keyword">synchronized</span>(o)&#123;<br>                            <span class="hljs-keyword">if</span>(cnt&gt;=<span class="hljs-number">2000000</span>)&#123;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            <span class="hljs-comment">//System.out.println(Thread.currentThread().getName()+&quot;:count:&quot;+(++cnt));</span><br>                            cnt ++;<br>                            <span class="hljs-comment">//测试时，线程更容易切换</span><br>                            Thread.yield();<br>                        &#125;<br>                    &#125;<br>                &#125;));<br>            &#125;<br>            ts.forEach(t -&gt; t.start());<br>            ts.forEach(t -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    t.join();<br>                &#125;<span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>            <span class="hljs-keyword">long</span> end = System.nanoTime();<br>            System.out.println(cnt + <span class="hljs-string">&quot; cost:&quot;</span> + (end - start)/<span class="hljs-number">1000_000</span>);<br>            cnt = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> </span>&#123;<br>        T adder = adderSupplier.get();<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50000</span>; j++) &#123;<br>                    action.accept(adder);<br>                &#125;<br>            &#125;));<br>        &#125;<br>        ts.forEach(t -&gt; t.start());<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<br>        System.out.println(adder + <span class="hljs-string">&quot; cost:&quot;</span> + (end - start)/<span class="hljs-number">1000_000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2022/01/01/cas%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211212010011609.png" alt="image-20211212010011609"></p>
<p>修改切换频率</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>) Thread.yield();<br></code></pre></td></tr></table></figure>

<p><img src="/2022/01/01/cas%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211212010739909.png" alt="image-20211212010739909"></p>
<p>经过实验可以发现使用累加器性能高很多，在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p>
<p><strong>深入理解LongAdder</strong></p>
<p>LongAdder类的关键域：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 累加单元数组, 懒惰初始化</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br><span class="hljs-comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> base;<br><span class="hljs-comment">// 在 cells 创建或扩容时, 置为 1, 表示加锁</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> cellsBusy;<br></code></pre></td></tr></table></figure>

<p>Cell类的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 防止缓存行伪共享</span><br><span class="hljs-meta">@sun</span>.misc.Contended<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cell</span> </span>&#123;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> value;<br>        Cell(<span class="hljs-keyword">long</span> x) &#123; value = x; &#125;<br><br>        <span class="hljs-comment">// 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值</span><br>        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">cas</span><span class="hljs-params">(<span class="hljs-keyword">long</span> prev, <span class="hljs-keyword">long</span> next)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-keyword">this</span>, valueOffset, prev, next);<br>        &#125;<br>        <span class="hljs-comment">// 省略不重要代码</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>缓存行伪共享</p>
<p>从缓存方面开始：</p>
<p><img src="/2022/01/01/cas%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211024191201842.png" alt="image-20211024191201842"></p>
<table>
<thead>
<tr>
<th>cpu到</th>
<th>需要的时钟周期(cycle)</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>1</td>
</tr>
<tr>
<td>L1</td>
<td>3-4</td>
</tr>
<tr>
<td>L2</td>
<td>10-20</td>
</tr>
<tr>
<td>L3</td>
<td>40-45</td>
</tr>
<tr>
<td>内存</td>
<td>120-240</td>
</tr>
</tbody></table>
<p>根据计算机组成原理的知识，CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。而缓存实际上是以缓存行为单位的，每个缓存行对应着一块内存，一般是64字节。</p>
<p>缓存的加入会造成数据副本产生，即同一份数据会被缓存在不同核心的缓存行当中。然而CPU要保证数据一致性，如果某个CPU核心更改了数据，其它CPU核心对应的整个缓存行必须失效。</p>
<p><img src="/2022/01/01/cas%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211024191818726.png" alt="image-20211024191818726"></p>
<p>LongAdder中采用的是Cell累加方式，Cell是数组形式，在内存当中是连续存储的，一个Cell为24字节(16字节对象头以及8字节的value)，所以一般来说一个缓存行可以存下2个Cell对象。此时就会出现问题：</p>
<p>CPU核心0需要修改Cell[0]，CPU核心1要修改Cell[1]，无论哪一个核心修改成功都会导致另一方对应的缓存行失效。比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效</p>
<p><strong>@sun.misc.Contended</strong>就解决了这个问题，其原理就是在使用此注解后的对象或者字段的前后各增加128字节大小的padding，从而使得将对象预读至缓存时占用的是不同的缓存行，从而不会造成对方的缓存行失效。</p>
<p><img src="/2022/01/01/cas%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211024193014159.png" alt="image-20211024193014159"></p>
<p><strong>累加源码分析</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;<br>    Cell[] as; <span class="hljs-keyword">long</span> b, v; <span class="hljs-keyword">int</span> m; Cell a;<br>    <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> || !casBase(b = base, b + x)) &#123;<br>        <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>            (a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||<br>            !(uncontended = a.cas(v = a.value, v + x)))<br>            longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">longAccumulate</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, LongBinaryOperator fn,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">boolean</span> wasUncontended)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123;<br>        ThreadLocalRandom.current(); <span class="hljs-comment">// force initialization</span><br>        h = getProbe();<br>        wasUncontended = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">boolean</span> collide = <span class="hljs-keyword">false</span>;                <span class="hljs-comment">// True if last slot nonempty</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Cell[] as; Cell a; <span class="hljs-keyword">int</span> n; <span class="hljs-keyword">long</span> v;<br>        <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">// Try to attach new Cell</span><br>                    Cell r = <span class="hljs-keyword">new</span> Cell(x);   <span class="hljs-comment">// Optimistically create</span><br>                    <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                        <span class="hljs-keyword">boolean</span> created = <span class="hljs-keyword">false</span>;<br>                        <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span><br>                            Cell[] rs; <span class="hljs-keyword">int</span> m, j;<br>                            <span class="hljs-keyword">if</span> ((rs = cells) != <span class="hljs-keyword">null</span> &amp;&amp;<br>                                (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                                rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-keyword">null</span>) &#123;<br>                                rs[j] = r;<br>                                created = <span class="hljs-keyword">true</span>;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            cellsBusy = <span class="hljs-number">0</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (created)<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// Slot is now non-empty</span><br>                    &#125;<br>                &#125;<br>                collide = <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)       <span class="hljs-comment">// CAS already known to fail</span><br>                wasUncontended = <span class="hljs-keyword">true</span>;      <span class="hljs-comment">// Continue after rehash</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.cas(v = a.value, ((fn == <span class="hljs-keyword">null</span>) ? v + x :<br>                                         fn.applyAsLong(v, x))))<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= NCPU || cells != as)<br>                collide = <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// At max size or stale</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)<br>                collide = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (cells == as) &#123;      <span class="hljs-comment">// Expand table unless stale</span><br>                        Cell[] rs = <span class="hljs-keyword">new</span> Cell[n &lt;&lt; <span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                            rs[i] = as[i];<br>                        cells = rs;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    cellsBusy = <span class="hljs-number">0</span>;<br>                &#125;<br>                collide = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">// Retry with expanded table</span><br>            &#125;<br>            h = advanceProbe(h);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;<br>            <span class="hljs-keyword">boolean</span> init = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;                           <span class="hljs-comment">// Initialize table</span><br>                <span class="hljs-keyword">if</span> (cells == as) &#123;<br>                    Cell[] rs = <span class="hljs-keyword">new</span> Cell[<span class="hljs-number">2</span>];<br>                    rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Cell(x);<br>                    cells = rs;<br>                    init = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                cellsBusy = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (init)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casBase(v = base, ((fn == <span class="hljs-keyword">null</span>) ? v + x :<br>                                    fn.applyAsLong(v, x))))<br>            <span class="hljs-keyword">break</span>;                          <span class="hljs-comment">// Fall back on using base</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> </span>&#123;<br>    Cell[] as = cells; Cell a;<br>    <span class="hljs-keyword">long</span> sum = base;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-keyword">null</span>)<br>                sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>

<div id="paginator"></div></div><p><strong>本文标题</strong>：cas深入理解<br><strong>本文作者</strong>：MaoZH<br><strong>本文链接</strong>：<a href="/2022/01/01/cas%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/">https://jack-edward.github.io/2022/01/01/cas%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</a><br><strong>版权声明</strong>：转载或借鉴请注明出处，保留以上声明信息！</p><div class="post_share"><div class="social-share share-component" data-image="https://cdn.jsdelivr.net/gh/hassanblog/CDN/img/cover_character_drawing.png" data-sites="facebook,twitter,wechat,weibo,qq,qzone,tencent,douban,diandian,google,linkedin"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="all" onload="this.media=&quot;all&quot;"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer=""></script></div><div id="post-footer"><hr><a href="/2021/12/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">每日一题 Next →</a><hr></div><div id="bottom-btn"><a id="to-index" href="#post-index" title="index">≡</a><a id="to-top" href="#post-title" title="to top">∧</a></div><div id="Valine"></div><script>new Valine({
 el: '#Valine'
 , appId: 'TWFe26C7GQDWyvw3lVpQUswj-gzGzoHsz'
 , appKey: 'kA8WG8bPJQ16UwOnhf7TGdHn'
 , placeholder: '欢迎大家评论，感谢批评指正'
})</script></div></article><aside><form><div class="tipue_search_group"><input id="tipue_search_input" type="text" name="q" placeholder="Search Here" pattern=".{3,}" title="At least 3 characters" autofocus="autofocus" required=""><button class="tipue_search_button" type="submit"><div class="tipue_search_icon">⚲</div></button></div></form><div id="tipue_search_content"></div><script>$(document).ready(function() {
$('#tipue_search_input').tipuesearch();
});</script><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><div id="he-plugin-standard"></div><script>WIDGET = {
"CONFIG": {
"layout": "1",
"width": 450,
"height": 150,
"background": "3",
"dataColor": "FFFFFF",
"key": "e2043117ad6d459bb0eb89b26de1b4a2"
}
}</script><script src="https://widget.qweather.net/standard/static/js/he-standard-common.js?v=2.0"></script><h1 id="dr"><a href="/"> Mr.MaoZH</a></h1><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">10</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">11</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">4</span></div></section></div><div id="about-me"><span class="about-me">Contact-me:</span><a href="tencent://message/?uin=3128633651&amp;amp;site=qq&amp;amp;menu=yes"><img src="https://im.qq.com/favicon.ico"></a><a href="mailto:3128633651@qq.com"><img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/email.svg" width="20"></a></div><div id="aside-block"><div id="aside"><h1>INDEX</h1><div id="post-index"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81CAS%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、CAS概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">二、底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%8C%87%E4%BB%A4%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">CPU实现原子指令的方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.</span> <span class="toc-text">1.入门实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">2.原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">2.1原子整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">2.2原子引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3ABA%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.</span> <span class="toc-text">2.3ABA问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">4.4.</span> <span class="toc-text">2.4原子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">2.5字段更新器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6%E5%8E%9F%E5%AD%90%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="toc-number">4.6.</span> <span class="toc-text">2.6原子累加器</span></a></li></ol></li></ol></div><div id="post-index"></div></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">2020 to 2021</span></nobr><wbr><nobr><span class="text-title">ICP</span><span class="text-content">——备案号——</span></nobr><wbr><wbr><nobr>published with&nbsp;<a href="https://jack-edward.github.io">Zhihui Mao&nbsp;</a></nobr><wbr><nobr>Theme&nbsp;<a href="">Arknight&nbsp;</a></nobr><wbr><nobr>by&nbsp;<a href="">Yue_plus </a></nobr><wbr><script type="text/javascript" src="jquery.min.js"></script><script type="text/javascript">$(document).ready(function(){
//通过调用新浪IP地址库接口查询用户当前所在国家、省份、城市、运营商信息
$.getScript('https://pv.sohu.com/cityjson?ie=utf-8',function(){
$(".city").html(returnCitySN.cname);
$(".ip").html(returnCitySN.cip);
//$(".browser").html(navigator.appVersion);
});
});</script></footer><div>欢迎来自<span class="city"></span>地区的朋友<br>您的IP地址为：<span class="ip"></span><!--| <br>您的浏览器为：--><!--span.browser--><wbr><script type="text/javascript" src="//rf.revolvermaps.com/0/0/1.js?i=52al2pyccg1&amp;s=216&amp;m=0&amp;v=true&amp;r=false&amp;b=000000&amp;n=false&amp;c=ff0000" async="async"></script><wbr><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=406086764&auto=0&height=66"></iframe></div></aside></main><canvas id="canvas-dust"></canvas><script src="/js/arknights.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script></body></html>