<!DOCTYPE html><html lang="en"><script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><script src="/live2d-widget/autoload.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="/tipuesearch/tipuesearch_content.js"></script><link rel="stylesheet" href="/tipuesearch/tipuesearch.css"><script src="/tipuesearch/tipuesearch_set.js"></script><script src="/tipuesearch/tipuesearch.min.js"></script><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>每日一题 | MaoZH</title><script src="https://cdn.bootcss.com/valine/1.4.4/Valine.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/mermaid/8.11.0/mermaid.min.js"></script><script>mermaid.initialize({
  startOnLoad: true
  , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="MaoZH" type="application/atom+xml">
</head><body><header><nav><a href="/">Home</a><a href="/archives/">Archives</a></nav></header><main><article><div id="post-bg"><div id="post-title"><h1>每日一题</h1><hr></div><div id="post-content"><p>本篇博客主要用于记录力扣每日一题的一些有趣的算法以及数据结构，不定时长期更新。</p>
<p><img src="/2021/10/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20211010194009496.png" alt="image-20211010194009496"></p>
<span id="more"></span>

<h2 id="1-二分法"><a href="#1-二分法" class="headerlink" title="1.二分法"></a>1.二分法</h2><p>你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。</p>
<p><img src="/2021/10/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20211010161909387.png" alt="image-20211010161909387"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">arrangeCoins</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = (<span class="hljs-keyword">int</span>)Math.sqrt(n);<br>        <span class="hljs-keyword">int</span> right = n;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> mid = (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">long</span>)mid * (<span class="hljs-keyword">long</span>)(mid + <span class="hljs-number">1</span>) &lt;= (<span class="hljs-keyword">long</span>)<span class="hljs-number">2</span> * n) &#123;<span class="hljs-comment">//等号偏向于&lt;一方</span><br>                left = mid;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>本题主要不在该题目，而是所使用的二分法：二分法作为最常见的一种算法，常用于有序序列的查找和插入等场景，由于其时间复杂度比较低，因此常用于优化算法中。二分法的使用有些需要注意的地方：</p>
<ul>
<li>对于在找寻一个特定的值的时候，且该值是确定的位置的时候，此时二分法就采用中规中矩的方法，分别计算mid；讨论等于mid，大于mid，小于mid的情况</li>
<li>但是肯定会存在找寻的是一个不确定的值，此时只能通过缩小区间找到该值，此时也就是会将其中等于的情况偏向其中一种，此时需要注意：<ul>
<li>求取mid的时候需要额外加1(即使用使用(right - left + 1) / 2 + left)，让mid下次循环自动右移</li>
<li>由于此时mid下次循环会自动右移，因此在满足相应条件<strong>left指针</strong>赋值的时候选择left=mid，不需要加1，不能对right赋值为mid，因为right指针是往左移的</li>
</ul>
</li>
</ul>
<h2 id="2-并查集"><a href="#2-并查集" class="headerlink" title="2.并查集"></a>2.并查集</h2><p>给你一个二维 rows x columns 的地图 heights ，其中 heights [row] [col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。请你返回从左上角走到右下角的最小 体力消耗值 。</p>
<p><img src="/2021/10/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20211010171007293.png" alt="image-20211010171007293"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] heights)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = heights.length;<br>        <span class="hljs-keyword">int</span> n = heights[<span class="hljs-number">0</span>].length;<br>        List&lt;<span class="hljs-keyword">int</span>[]&gt; edges = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">int</span> pos = i * n + j;<br>                <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">1</span>) edges.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;pos - n, pos, Math.abs(heights[i - <span class="hljs-number">1</span>][j] - heights[i][j])&#125;);<br>                <span class="hljs-keyword">if</span>(j &gt;= <span class="hljs-number">1</span>) edges.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;pos - <span class="hljs-number">1</span>, pos, Math.abs(heights[i][j - <span class="hljs-number">1</span>] - heights[i][j])&#125;);<br>            &#125;<br>        &#125;<br>        Collections.sort(edges, (a, b) -&gt; a[<span class="hljs-number">2</span>] - b[<span class="hljs-number">2</span>]);<br>        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(m * n);<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] edge : edges)&#123;<br>            uf.union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span>(uf.connected(<span class="hljs-number">0</span>, m * n - <span class="hljs-number">1</span>))&#123;<br>                ans = edge[<span class="hljs-number">2</span>];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> setCount;<br>    <span class="hljs-keyword">int</span>[] parent;<br>    <span class="hljs-keyword">int</span>[] size;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.n = n;<br>        <span class="hljs-keyword">this</span>.setCount = n;<br>        <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">this</span>.size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        Arrays.fill(size, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            parent[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x != parent[x])&#123;<br>            x = find(parent[x]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        x = find(x);<br>        y = find(y);<br>        <span class="hljs-keyword">if</span>(x == y) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span>(size[x] &lt; size[y])&#123;<br>            <span class="hljs-keyword">int</span> tmp = x;<br>            x = y;<br>            y = tmp;<br>        &#125;<br>        parent[y] = x;<br>        size[x] += size[y];<br>        setCount --;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        x = find(x);<br>        y = find(y);<br>        <span class="hljs-keyword">return</span> x == y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>本题采用的是一种并查集数据结构来解决问题的。并查集主要用于解决动态连通性一类问题的一种算法，称为Union-Find。</p>
<p>并查集视频讲解：<a target="_blank" rel="noopener" href="https://b23.tv/T7Dvkw">https://b23.tv/T7Dvkw</a></p>
<p><strong>动态连通性的应用场景：</strong></p>
<ul>
<li>比如如果每个pair中的两个整数分别代表一个网络节点，那么该pair就是用来表示这两个节点是需要连通的。那么为所有的pairs建立了动态连通图时，已经连通的两个节点的边会被直接忽略掉，就能够尽可能少的减少布线的需要</li>
<li>树(图网络)的根节点问题，判断两个结点是否具有相同的根节点</li>
<li>给出两个节点，判断它们是否连通，且不需要给出具体的路径，可以使用这种方法</li>
</ul>
<p>最简单而直观的假设是，对于连通的所有节点，我们可以认为它们属于一个组，因此不连通的节点必然就属于不同的组。随着Pair边的不断输入，我们需要首先判断输入的两个节点是否连通。如何判断呢？按照上面的假设，我们可以通过判断它们属于的组，然后看看这两个组是否相同，如果相同，那么这两个节点连通，反之不连通。</p>
<p>1.根据所有的点对连通图初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.n = n;<span class="hljs-comment">//点的数目</span><br>        <span class="hljs-keyword">this</span>.setCount = n;<span class="hljs-comment">//分组数目</span><br>        <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<span class="hljs-comment">//记录每个点的父亲结点</span><br>        <span class="hljs-keyword">this</span>.size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<span class="hljs-comment">//记录以当前结点为根节点的树的结点数目</span><br>        Arrays.fill(size, <span class="hljs-number">1</span>);<span class="hljs-comment">//对深度进行初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            parent[i] = i;<span class="hljs-comment">//初始化对应结点的父节点</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>2.初始化完毕后，还要进行一些操作</p>
<ul>
<li>找出某个点的根节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x != parent[x])&#123;<br>        x = find(parent[x]);<span class="hljs-comment">//采用递归不断向上查找父节点直到到达根节点</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> parent[x];<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>判断两个点是否再同一个组当中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        x = find(x);<br>        y = find(y);<br>        <span class="hljs-keyword">return</span> x == y;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>直接找出两点的根节点是否相等，相等则说明它们是相连的</p>
<ul>
<li>根据两点形成的边进行Union操作</li>
</ul>
<p>1.普通的union操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (parent[x] != -<span class="hljs-number">1</span> &amp;&amp; parent[y] != -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">int</span> rootx = find(x);<br>        <span class="hljs-keyword">int</span> rooty = find(y);<br>        <span class="hljs-keyword">if</span> (rootx != rooty) &#123;<br>            parent[rootx] = rooty;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，这种方法就是始终选择把x链接到y上，即x根节点rootx的父节点置为y根节点rooty，这样做很容易会出现极端情况，其中一些组的深度非常大，影响效率，如下图：</p>
<p><img src="/2021/10/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20211010184456953.png" alt="image-20211010184456953"></p>
<p>2.优化union操作</p>
<p>使用size[]数组的方式：(size[]初始化为1，因为当前只有一个点)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    x = find(x);<br>    y = find(y);<br>    <span class="hljs-keyword">if</span>(x == y) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span>(size[x] &lt; size[y])&#123;<span class="hljs-comment">//始终将x作为数目最多的根节点</span><br>        <span class="hljs-keyword">int</span> tmp = x;<br>        x = y;<br>        y = tmp;<br>    &#125;<br>    parent[y] = x;<br>    size[x] += size[y];<span class="hljs-comment">//链接后x组结点数目就要加上y中的</span><br>    setCount --;<span class="hljs-comment">//由于两个组链接在一起了，分组的数目减一</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用一个size[]数组记录以该结点为根节点的所有树节点的数目（或者用rank[]数组用于记录以当前节点为根节点的深度），然后在选择把结点数目少的链接到结点数目大的上；然后链接完后需要更新链接完后结点数目，并且由于合并了两个分组因此分组数目减1</p>
<p><img src="/2021/10/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20211010184658839.png" alt="image-20211010184658839"></p>
<p>使用rank[]数组的方式：(rank()初始化为0)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    rootx = find(x);<br>    rooty = find(y);<br>    <span class="hljs-keyword">if</span>(rootx == rooty) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span>(rank[rootx] &lt; rank[rooty])&#123;<span class="hljs-comment">//选择深度小的结点链接到深度大的结点上去</span><br>        parent[rootx] = rooty;<span class="hljs-comment">//rank[rootx]与rank[rooty]未发生变化</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[rootx] &gt; rank[rooty])&#123;<br>        parent[rooty] = rootx;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        parent[rooty] = rootx;<span class="hljs-comment">//此时相等，随机链接</span><br>        rank[rootx] ++;<span class="hljs-comment">//此时rooty链接到rootx上，因此rootx深度加1</span><br>    &#125;<br>    setCount --;<span class="hljs-comment">//由于两个组链接在一起了，分组的数目减一</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>附参考博客：<a target="_blank" rel="noopener" href="https://destiny1020.blog.csdn.net/article/details/7655764">https://destiny1020.blog.csdn.net/article/details/7655764</a></p>
<div id="paginator"></div></div><p><strong>本文标题</strong>：每日一题<br><strong>本文作者</strong>：MaoZH<br><strong>本文链接</strong>：<a href="/2021/10/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">https://jack-edward.github.io/2021/10/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</a><br><strong>版权声明</strong>：转载或借鉴请注明出处，保留以上声明信息！</p><div class="post_share"><div class="social-share share-component" data-image="https://cdn.jsdelivr.net/gh/hassanblog/CDN/img/cover_character_drawing.png" data-sites="facebook,twitter,wechat,weibo,qq,qzone,tencent,douban,diandian,google,linkedin"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="all" onload="this.media=&quot;all&quot;"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer=""></script></div><div id="post-footer"><hr><a href="/2021/10/06/Hive%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/">Hive数据仓库 Next →</a><hr></div><div id="bottom-btn"><a id="to-index" href="#post-index" title="index">≡</a><a id="to-top" href="#post-title" title="to top">∧</a></div><div id="Valine"></div><script>new Valine({
 el: '#Valine'
 , appId: 'TWFe26C7GQDWyvw3lVpQUswj-gzGzoHsz'
 , appKey: 'kA8WG8bPJQ16UwOnhf7TGdHn'
 , placeholder: '欢迎大家评论，感谢批评指正'
})</script></div></article><aside><form><div class="tipue_search_group"><input id="tipue_search_input" type="text" name="q" placeholder="Search Here" pattern=".{3,}" title="At least 3 characters" autofocus="autofocus" required=""><button class="tipue_search_button" type="submit"><div class="tipue_search_icon">⚲</div></button></div></form><div id="tipue_search_content"></div><script>$(document).ready(function() {
$('#tipue_search_input').tipuesearch();
});</script><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><div id="he-plugin-standard"></div><script>WIDGET = {
"CONFIG": {
"layout": "1",
"width": 450,
"height": 150,
"background": "3",
"dataColor": "FFFFFF",
"key": "e2043117ad6d459bb0eb89b26de1b4a2"
}
}</script><script src="https://widget.qweather.net/standard/static/js/he-standard-common.js?v=2.0"></script><h1 id="dr"><a href="/"> Mr.MaoZH</a></h1><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">6</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">7</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">3</span></div></section></div><div id="about-me"><span class="about-me">Contact-me:</span><a href="tencent://message/?uin=3128633651&amp;amp;site=qq&amp;amp;menu=yes"><img src="https://im.qq.com/favicon.ico"></a><a href="mailto:3128633651@qq.com"><img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/email.svg" width="20"></a></div><div id="aside-block"><div id="aside"><h1>INDEX</h1><div id="post-index"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BA%8C%E5%88%86%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">1.二分法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">2.</span> <span class="toc-text">2.并查集</span></a></li></ol></div><div id="post-index"></div></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">2020 to 2021</span></nobr><wbr><nobr><span class="text-title">ICP</span><span class="text-content">——备案号——</span></nobr><wbr><wbr><nobr>published with&nbsp;<a href="https://jack-edward.github.io">Zhihui Mao&nbsp;</a></nobr><wbr><nobr>Theme&nbsp;<a href="">Arknight&nbsp;</a></nobr><wbr><nobr>by&nbsp;<a href="">Yue_plus </a></nobr><wbr><script type="text/javascript" src="jquery.min.js"></script><script type="text/javascript">$(document).ready(function(){
//通过调用新浪IP地址库接口查询用户当前所在国家、省份、城市、运营商信息
$.getScript('https://pv.sohu.com/cityjson?ie=utf-8',function(){
$(".city").html(returnCitySN.cname);
$(".ip").html(returnCitySN.cip);
//$(".browser").html(navigator.appVersion);
});
});</script></footer><div>欢迎来自<span class="city"></span>地区的朋友<br>您的IP地址为：<span class="ip"></span><!--| <br>您的浏览器为：--><!--span.browser--><wbr><script type="text/javascript" src="//rf.revolvermaps.com/0/0/1.js?i=52al2pyccg1&amp;s=216&amp;m=0&amp;v=true&amp;r=false&amp;b=000000&amp;n=false&amp;c=ff0000" async="async"></script><wbr><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=406086764&auto=0&height=66"></iframe></div></aside></main><canvas id="canvas-dust"></canvas><script src="/js/arknights.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script></body></html>