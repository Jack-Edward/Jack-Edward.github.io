<!DOCTYPE html><html lang="en"><script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><script src="/live2d-widget/autoload.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="/tipuesearch/tipuesearch_content.js"></script><link rel="stylesheet" href="/tipuesearch/tipuesearch.css"><script src="/tipuesearch/tipuesearch_set.js"></script><script src="/tipuesearch/tipuesearch.min.js"></script><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>每日一题 | MaoZH</title><script src="https://cdn.bootcss.com/valine/1.4.4/Valine.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/mermaid/8.11.0/mermaid.min.js"></script><script>mermaid.initialize({
  startOnLoad: true
  , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="MaoZH" type="application/atom+xml">
</head><body><header><nav><a href="/">Home</a><a href="/archives/">Archives</a></nav></header><main><article><div id="post-bg"><div id="post-title"><h1>每日一题</h1><hr></div><div id="post-content"><p>本篇博客主要用于记录力扣每日一题的一些有趣的算法以及数据结构，不定时长期更新。</p>
<p><img src="/2021/10/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20211010194009496.png" alt="image-20211010194009496"></p>
<span id="more"></span>

<h2 id="1-二分法"><a href="#1-二分法" class="headerlink" title="1.二分法"></a>1.二分法</h2><p>你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。</p>
<p><img src="/2021/10/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20211010161909387.png" alt="image-20211010161909387"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">arrangeCoins</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = (<span class="hljs-keyword">int</span>)Math.sqrt(n);<br>        <span class="hljs-keyword">int</span> right = n;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> mid = (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">long</span>)mid * (<span class="hljs-keyword">long</span>)(mid + <span class="hljs-number">1</span>) &lt;= (<span class="hljs-keyword">long</span>)<span class="hljs-number">2</span> * n) &#123;<span class="hljs-comment">//等号偏向于&lt;一方</span><br>                left = mid;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>本题主要不在该题目，而是所使用的二分法：二分法作为最常见的一种算法，常用于有序序列的查找和插入等场景，由于其时间复杂度比较低，因此常用于优化算法中。二分法的使用有些需要注意的地方：</p>
<ul>
<li>对于在找寻一个特定的值的时候，且该值是确定的位置的时候，此时二分法就采用中规中矩的方法，分别计算mid；讨论等于mid，大于mid，小于mid的情况</li>
<li>但是肯定会存在找寻的是一个不确定的值，此时只能通过缩小区间找到该值，此时也就是会将其中等于的情况偏向其中一种，此时需要注意：<ul>
<li>求取mid的时候需要额外加1(即使用使用(right - left + 1) / 2 + left)，让mid下次循环自动右移</li>
<li>由于此时mid下次循环会自动右移，因此在满足相应条件<strong>left指针</strong>赋值的时候选择left=mid，不需要加1，不能对right赋值为mid，因为right指针是往左移的</li>
</ul>
</li>
</ul>
<h2 id="2-并查集"><a href="#2-并查集" class="headerlink" title="2.并查集"></a>2.并查集</h2><p>给你一个二维 rows x columns 的地图 heights ，其中 heights [row] [col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。请你返回从左上角走到右下角的最小 体力消耗值 。</p>
<p><img src="/2021/10/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20211010171007293.png" alt="image-20211010171007293"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] heights)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = heights.length;<br>        <span class="hljs-keyword">int</span> n = heights[<span class="hljs-number">0</span>].length;<br>        List&lt;<span class="hljs-keyword">int</span>[]&gt; edges = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">int</span> pos = i * n + j;<br>                <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">1</span>) edges.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;pos - n, pos, Math.abs(heights[i - <span class="hljs-number">1</span>][j] - heights[i][j])&#125;);<br>                <span class="hljs-keyword">if</span>(j &gt;= <span class="hljs-number">1</span>) edges.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;pos - <span class="hljs-number">1</span>, pos, Math.abs(heights[i][j - <span class="hljs-number">1</span>] - heights[i][j])&#125;);<br>            &#125;<br>        &#125;<br>        Collections.sort(edges, (a, b) -&gt; a[<span class="hljs-number">2</span>] - b[<span class="hljs-number">2</span>]);<br>        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(m * n);<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] edge : edges)&#123;<br>            uf.union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span>(uf.connected(<span class="hljs-number">0</span>, m * n - <span class="hljs-number">1</span>))&#123;<br>                ans = edge[<span class="hljs-number">2</span>];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> setCount;<br>    <span class="hljs-keyword">int</span>[] parent;<br>    <span class="hljs-keyword">int</span>[] size;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.n = n;<br>        <span class="hljs-keyword">this</span>.setCount = n;<br>        <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">this</span>.size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        Arrays.fill(size, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            parent[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x != parent[x])&#123;<br>            x = find(parent[x]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        x = find(x);<br>        y = find(y);<br>        <span class="hljs-keyword">if</span>(x == y) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span>(size[x] &lt; size[y])&#123;<br>            <span class="hljs-keyword">int</span> tmp = x;<br>            x = y;<br>            y = tmp;<br>        &#125;<br>        parent[y] = x;<br>        size[x] += size[y];<br>        setCount --;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        x = find(x);<br>        y = find(y);<br>        <span class="hljs-keyword">return</span> x == y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>本题采用的是一种并查集数据结构来解决问题的。并查集主要用于解决动态连通性一类问题的一种算法，称为Union-Find。</p>
<p>并查集视频讲解：<a target="_blank" rel="noopener" href="https://b23.tv/T7Dvkw">https://b23.tv/T7Dvkw</a></p>
<p><strong>动态连通性的应用场景：</strong></p>
<ul>
<li>比如如果每个pair中的两个整数分别代表一个网络节点，那么该pair就是用来表示这两个节点是需要连通的。那么为所有的pairs建立了动态连通图时，已经连通的两个节点的边会被直接忽略掉，就能够尽可能少的减少布线的需要</li>
<li>树(图网络)的根节点问题，判断两个结点是否具有相同的根节点</li>
<li>给出两个节点，判断它们是否连通，且不需要给出具体的路径，可以使用这种方法</li>
</ul>
<p><font face="楷体" color="4169E1">最简单而直观的假设是，对于连通的所有节点，我们可以认为它们属于一个组，因此不连通的节点必然就属于不同的组。随着Pair边的不断输入，我们需要首先判断输入的两个节点是否连通。如何判断呢？按照上面的假设，我们可以通过判断它们属于的组，然后看看这两个组是否相同，如果相同，那么这两个节点连通，反之不连通。</font></p>
<p>1.根据所有的点对连通图初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.n = n;<span class="hljs-comment">//点的数目</span><br>        <span class="hljs-keyword">this</span>.setCount = n;<span class="hljs-comment">//分组数目</span><br>        <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<span class="hljs-comment">//记录每个点的父亲结点</span><br>        <span class="hljs-keyword">this</span>.size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<span class="hljs-comment">//记录以当前结点为根节点的树的结点数目</span><br>        Arrays.fill(size, <span class="hljs-number">1</span>);<span class="hljs-comment">//对深度进行初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            parent[i] = i;<span class="hljs-comment">//初始化对应结点的父节点</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>2.初始化完毕后，还要进行一些操作</p>
<ul>
<li>找出某个点的根节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x != parent[x])&#123;<br>        x = find(parent[x]);<span class="hljs-comment">//采用递归不断向上查找父节点直到到达根节点</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> parent[x];<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>判断两个点是否再同一个组当中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        x = find(x);<br>        y = find(y);<br>        <span class="hljs-keyword">return</span> x == y;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>直接找出两点的根节点是否相等，相等则说明它们是相连的</p>
<ul>
<li>根据两点形成的边进行Union操作</li>
</ul>
<p>1.普通的union操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (parent[x] != -<span class="hljs-number">1</span> &amp;&amp; parent[y] != -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">int</span> rootx = find(x);<br>        <span class="hljs-keyword">int</span> rooty = find(y);<br>        <span class="hljs-keyword">if</span> (rootx != rooty) &#123;<br>            parent[rootx] = rooty;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，这种方法就是始终选择把x链接到y上，即x根节点rootx的父节点置为y根节点rooty，这样做很容易会出现极端情况，其中一些组的深度非常大，影响效率，如下图：</p>
<p><img src="/2021/10/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20211010184456953.png" alt="image-20211010184456953"></p>
<p>2.优化union操作</p>
<p>使用size[]数组的方式：(size[]初始化为1，因为当前只有一个点)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    x = find(x);<br>    y = find(y);<br>    <span class="hljs-keyword">if</span>(x == y) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span>(size[x] &lt; size[y])&#123;<span class="hljs-comment">//始终将x作为数目最多的根节点</span><br>        <span class="hljs-keyword">int</span> tmp = x;<br>        x = y;<br>        y = tmp;<br>    &#125;<br>    parent[y] = x;<br>    size[x] += size[y];<span class="hljs-comment">//链接后x组结点数目就要加上y中的</span><br>    setCount --;<span class="hljs-comment">//由于两个组链接在一起了，分组的数目减一</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用一个size[]数组记录以该结点为根节点的所有树节点的数目（或者用rank[]数组用于记录以当前节点为根节点的深度），然后在选择把结点数目少的链接到结点数目大的上；然后链接完后需要更新链接完后结点数目，并且由于合并了两个分组因此分组数目减1</p>
<p><img src="/2021/10/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20211010184658839.png" alt="image-20211010184658839"></p>
<p>使用rank[]数组的方式：(rank()初始化为0)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    rootx = find(x);<br>    rooty = find(y);<br>    <span class="hljs-keyword">if</span>(rootx == rooty) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span>(rank[rootx] &lt; rank[rooty])&#123;<span class="hljs-comment">//选择深度小的结点链接到深度大的结点上去</span><br>        parent[rootx] = rooty;<span class="hljs-comment">//rank[rootx]与rank[rooty]未发生变化</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[rootx] &gt; rank[rooty])&#123;<br>        parent[rooty] = rootx;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        parent[rooty] = rootx;<span class="hljs-comment">//此时相等，随机链接</span><br>        rank[rootx] ++;<span class="hljs-comment">//此时rooty链接到rootx上，因此rootx深度加1</span><br>    &#125;<br>    setCount --;<span class="hljs-comment">//由于两个组链接在一起了，分组的数目减一</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>附参考博客：<a target="_blank" rel="noopener" href="https://destiny1020.blog.csdn.net/article/details/7655764">https://destiny1020.blog.csdn.net/article/details/7655764</a></p>
<h2 id="3-递归"><a href="#3-递归" class="headerlink" title="3.递归"></a>3.递归</h2><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。返回被除数 dividend 除以除数 divisor 得到的商。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dividend, <span class="hljs-keyword">int</span> divisor)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (dividend == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (divisor == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (dividend &gt; Integer.MIN_VALUE) <span class="hljs-keyword">return</span> -dividend;<br>            <span class="hljs-keyword">return</span> Integer.MAX_VALUE;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> dividend;<br>        <span class="hljs-keyword">long</span> a = dividend, b = divisor;<br>        <span class="hljs-keyword">int</span> sign = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> ((dividend &gt; <span class="hljs-number">0</span> &amp;&amp; divisor &lt; <span class="hljs-number">0</span>) || (dividend &lt; <span class="hljs-number">0</span> &amp;&amp; divisor &gt; <span class="hljs-number">0</span>)) sign = -<span class="hljs-number">1</span>;<br>        a = a &gt; <span class="hljs-number">0</span> ? a : -a;<br>        b = b &gt; <span class="hljs-number">0</span> ? b : -b;<br>        <span class="hljs-keyword">return</span> sign == <span class="hljs-number">1</span> ? (get(a, b) &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : get(a, b)): -get(a, b);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (a &lt; b) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">long</span> accumulate = b;<br>        <span class="hljs-keyword">while</span> (accumulate + accumulate &lt;= a) &#123;<br>            count += count;<span class="hljs-comment">//所得的结果值也要对应翻倍</span><br>            accumulate += accumulate;<span class="hljs-comment">//将除数翻倍</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> count + get(a - accumulate, b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>这个题主要使用了递归的思想，由于不能使用乘法，因此只能使用原始的定义，通过不断将被除数减去除数，通过记录减的次数得到商</li>
<li>但是，由于这样每次减一个除数对于除数特别小，被除数特别大时效率非常低；因此可以考虑每次都将被除数减去最大的除数的2^n倍，使得恰好剩余的被除数大于等于0；这样指数式增长往往能大大提高效率。比如：50 / 4 = (50-32)/4 + 8 = 18 / 4 + 8 =(18 - 16) / 4 + 8 + 4 = 12</li>
<li>思考：遇到类似于这种题，应该优先考虑到递归方法，递归时往往不断将子问题减半，大大提升效率。</li>
</ul>
<h2 id="4-回溯法"><a href="#4-回溯法" class="headerlink" title="4.回溯法"></a>4.回溯法</h2><p>给定一个仅包含数字 0-9 的字符串 num 和一个目标值整数 target ，在 num 的数字之间添加 二元 运算符（不是一元）+、- 或 * ，返回所有能够得到目标值的表式。</p>
<p><img src="/2021/10/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20211016164917613.png" alt="image-20211016164917613"></p>
<p>初始的想法就是使用dfs遍历出所有的表达式，即在数字之间填入所有的可能符号，这种方法时间复杂度为O(n*4^n)。</p>
<p>优化：使用index记录当前决策到的位置以及当前得到的计算值，同时记录最后一次计算的末位数，最后对决策表达式中的第K部分时进行分情况讨论：</p>
<ul>
<li>若为+操作，得到第K项值为k，使用cur+k更新k，同时下一次遍历的pre更新为k</li>
<li>若为-操作，得到第K项值为k，使用cur-k更新k，同时下一次遍历的pre更新为-k</li>
<li>若为*操作，得到第K项值为k，考虑计算优先级问题，此次是k与上一次的pre相乘，由于cur已经加了pre，所以使用cur-pre+k * prev更新k，同时下一次遍历的pre更新为k * prev</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> target;<br>    String num;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">addOperators</span><span class="hljs-params">(String num, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.n = num.length();<br>        <span class="hljs-keyword">this</span>.target = target;<br>        <span class="hljs-keyword">this</span>.num = num;<br>        dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">long</span> pre, <span class="hljs-keyword">long</span> cur, String ret)</span> </span>&#123;<span class="hljs-comment">//pre为记录前一个数,cur为记录到达当前位置时得到的值</span><br>        <span class="hljs-keyword">if</span> (index == n) &#123;<br>            <span class="hljs-keyword">if</span> (cur == target) &#123;<br>                ans.add(ret);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (i != index &amp;&amp; num.charAt(index) == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//去除掉以0开头的数字情况(剪枝策略)</span><br>            <span class="hljs-keyword">long</span> k = Long.parseLong(num.substring(index, i + <span class="hljs-number">1</span>));<span class="hljs-comment">//取相应长度的数字拼成树</span><br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>                dfs(i + <span class="hljs-number">1</span>, k, k, <span class="hljs-string">&quot;&quot;</span> + k);<span class="hljs-comment">//初始遍历,还没有前数</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                dfs(i + <span class="hljs-number">1</span>, k, cur + k, ret + <span class="hljs-string">&quot;+&quot;</span> + k);<span class="hljs-comment">//考虑填加号</span><br>                dfs(i + <span class="hljs-number">1</span>, -k, cur - k, ret + <span class="hljs-string">&quot;-&quot;</span> + k);<span class="hljs-comment">//考虑填减号</span><br>                <span class="hljs-keyword">long</span> prev = pre * k;<br>                dfs(i + <span class="hljs-number">1</span>, prev, cur - pre + prev, ret + <span class="hljs-string">&quot;*&quot;</span> + k);<span class="hljs-comment">//考虑填乘号</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意这道题并没有用到许多剪枝策略，因此依然会比较耗时；由于运算时可能会出现减号，即使当前值cur大于目标结果也不能丢弃</strong></p>
<h3 id="回溯法总结"><a href="#回溯法总结" class="headerlink" title="回溯法总结"></a>回溯法总结</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>回溯法按深度优先策略搜索问题的解空间树。首先从根节点出发搜索解空间树，当算法搜索至解空间树的某一节点时，先利用<strong>剪枝函数</strong>判断该节点是否可行（即能得到问题的解）。如果不可行，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯；否则，进入该子树，继续按深度优先策略搜索。</p>
<p>回溯法的基本行为是搜索，搜索过程使用剪枝函数来为了避免无效的搜索。剪枝函数包括两类：1. 使用约束函数，剪去不满足约束条件的路径；2.使用限界函数，剪去不能得到最优解的路径。</p>
<h4 id="2-子集树与排列树"><a href="#2-子集树与排列树" class="headerlink" title="2.子集树与排列树"></a>2.子集树与排列树</h4><p>解空间树分为两种：子集树和排列树。顾名思义，子集树就是解是一个集合的子集问题；排列树就是遍历所有排列结果得到满足结果的问题。</p>
<p><strong>子集树</strong></p>
<p>从n个元素的集合S中找出满足某种性质的子集时，相应的解空间成为子集树，如背包问题</p>
<p><img src="/2021/10/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20211016174819918.png" alt="image-20211016174819918"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span></span>&#123;<span class="hljs-comment">//检查集合s中的第t个元素</span><br>	 <span class="hljs-keyword">if</span> (t &gt;= n)&#123; <span class="hljs-comment">//集合s中n个元素均检查完了</span><br>	 	handle(path)<span class="hljs-comment">//根据当前从根节点到叶节点的路径是否符合要求处理返回</span><br>	 &#125;<br>	 <span class="hljs-keyword">else</span> &#123;<br>		 <span class="hljs-comment">//构建l层的子集树，在n个元素中选择l个元素</span><br>		 <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; l; i++) &#123;<br>			 path.add(s[t-<span class="hljs-number">1</span>])<span class="hljs-comment">//选择第t个元素</span><br>			 <span class="hljs-keyword">if</span>(第t层(t个元素)满足约束)) dfs(t+<span class="hljs-number">1</span>)<span class="hljs-comment">//回溯t+1层(检查第t+1个元素)</span><br>			 path.remove(s[t])<span class="hljs-comment">//不选择第t个元素 </span><br>		 &#125;<br>	 &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>排列树</strong></p>
<p>确定n个元素满足某种性质的排列时，相应的解空间就是排列树，如旅行商问题</p>
<p><img src="/2021/10/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20211016174744109.png" alt="image-20211016174744109"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span></span>&#123;<span class="hljs-comment">//对集合s中的第t个元素排序</span><br>	 <span class="hljs-keyword">if</span> (t &gt;= n)&#123; <span class="hljs-comment">//集合s中n个元素已经排序完成</span><br>	 	handle(path)<span class="hljs-comment">//根据当前排序是否符合要求返回</span><br>	 &#125;<br>	 <span class="hljs-keyword">else</span> &#123;<br>		 <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = t; i &lt; s.size(); i++) &#123;<br>			 swap(s[t],s[i]) <span class="hljs-comment">//交换第t个元素和其后所有元素</span><br>			 <span class="hljs-keyword">if</span>(交换t和i元素之后满足约束)) <br>				dfs(t+<span class="hljs-number">1</span>) <span class="hljs-comment">//对第t+1个元素排序</span><br>			 swap(s[t],s[i]) <span class="hljs-comment">//替换回来往父节点进行回溯</span><br>		 &#125;<br>	 &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-回溯法实现"><a href="#3-回溯法实现" class="headerlink" title="3.回溯法实现"></a>3.回溯法实现</h4><p>回溯法的实现方法有两种：递归和递推</p>
<p><strong>递归</strong></p>
<p>思路简单，设计容易，但效率低</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//针对N叉树的递归回溯方法  </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">if</span> (t&gt;n) output(x); <span class="hljs-comment">//叶子节点，输出结果，x是可行解  </span><br>    <span class="hljs-keyword">else</span>  <br>       <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span> to k<span class="hljs-comment">//当前节点的所有子节点  </span><br>        &#123;  <br>            x[t]=value(i); <span class="hljs-comment">//每个子节点的值赋值给x  </span><br>            <span class="hljs-comment">//满足约束条件和限界条件  </span><br>          <span class="hljs-keyword">if</span> (constraint(t)&amp;&amp;bound(t))   <br>                backtrack(t+<span class="hljs-number">1</span>);  <span class="hljs-comment">//递归下一层  </span><br>        &#125;  <br>&#125; <br></code></pre></td></tr></table></figure>

<p><strong>递推</strong></p>
<p>算法相对复杂，效率较高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//针对N叉树的迭代回溯方法  </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">iterativeBacktrack</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">int</span> t=<span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">while</span> (t&gt;<span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-keyword">if</span>(ExistSubNode(t)) <span class="hljs-comment">//当前节点的存在子节点  </span><br>        &#123;  <br>            <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span> to k  <span class="hljs-comment">//遍历当前节点的所有子节点  </span><br>            &#123;  <br>                x[t]=value(i);<span class="hljs-comment">//每个子节点的值赋值给x  </span><br>                <span class="hljs-keyword">if</span> (constraint(t)&amp;&amp;bound(t))<span class="hljs-comment">//满足约束条件和限界条件   </span><br>                &#123;  <br>                    <span class="hljs-comment">//solution表示在节点t处得到了一个解  </span><br>                    <span class="hljs-keyword">if</span> (solution(t)) output(x);<span class="hljs-comment">//得到问题的一个可行解，输出  </span><br>                    <span class="hljs-keyword">else</span> t++;<span class="hljs-comment">//没有得到解，继续向下搜索  </span><br>                &#125;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">//不存在子节点，返回上一层  </span><br>        &#123;  <br>            t--;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure>

<h2 id="5-字典树"><a href="#5-字典树" class="headerlink" title="5.字典树"></a>5.字典树</h2><p>请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。</p>
<p>实现词典类 WordDictionary ：</p>
<p>WordDictionary() 初始化词典对象<br>void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配<br>bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回  false 。word 中可能包含一些 ‘.’ ，每个 . 都可以表示任何一个字母。</p>
<p><img src="/2021/10/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20211023162821305.png" alt="image-20211023162821305"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordDictionary</span> </span>&#123;<br>    Trie root;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WordDictionary</span><span class="hljs-params">()</span> </span>&#123;<br>        root = <span class="hljs-keyword">new</span> Trie();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addWord</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        root.insert(word);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dfs(word, <span class="hljs-number">0</span>, root);<br>    &#125;<br>	<span class="hljs-comment">//深度搜索，node记录当前搜索的节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String word, <span class="hljs-keyword">int</span> index, Trie node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == word.length()) &#123;<br>            <span class="hljs-keyword">return</span> node.isEnd;<br>        &#125;<br>        <span class="hljs-keyword">char</span> ch = word.charAt(index);<br>        <span class="hljs-comment">//当前的字符是字母，则查看其子节点是否存在该字母节点</span><br>        <span class="hljs-keyword">if</span> (Character.isLetter(ch)) &#123;<br>            Trie child = node.getChildren()[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (child != <span class="hljs-keyword">null</span> &amp;&amp; dfs(word, index + <span class="hljs-number">1</span>, child)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125; <br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果是.的话，则需要遍历所有不为空的子节点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i ++) &#123;<br>                Trie child = node.getChildren()[i];<br>                <span class="hljs-keyword">if</span> (child != <span class="hljs-keyword">null</span> &amp;&amp; dfs(word, index + <span class="hljs-number">1</span>, child)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span></span>&#123;<br>    <span class="hljs-keyword">public</span> Trie[] children;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isEnd;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;<br>        children = <span class="hljs-keyword">new</span> Trie[<span class="hljs-number">26</span>];<br>        isEnd = <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//插入字符操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Trie node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i ++) &#123;<br>            <span class="hljs-keyword">char</span> ch = word.charAt(i);<br>            <span class="hljs-comment">//看当前字符是否已经存在，不存在则新建并且移动节点到该最新节点</span><br>            <span class="hljs-keyword">if</span> (node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>) &#123;<br>                node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> Trie();<br>            &#125;<br>            node = node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        node.isEnd = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Trie node = searchPrefix(word);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-keyword">null</span> &amp;&amp; node.isEnd; <br>    &#125;<br>    <span class="hljs-comment">//找寻相应的字符前缀</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Trie <span class="hljs-title">searchPrefix</span><span class="hljs-params">(String prefix)</span> </span>&#123;<br>        Trie node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prefix.length(); i ++) &#123;<br>            <span class="hljs-keyword">char</span> ch = prefix.charAt(i);<br>            <span class="hljs-comment">//当前查找的字符对应节点不存在，说明不存在该前缀</span><br>            <span class="hljs-keyword">if</span> (node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>            node = node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Trie[] getChildren() &#123;<br>        <span class="hljs-keyword">return</span> children;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">getEnd</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> isEnd;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>字典树，又名前缀树，本质上就是一棵树，其每个节点包含以下字段：</p>
<ul>
<li>指向子节点的指针数组children，一般来说根据具体的问题分析相应的子节点个数。(对于本题而言，由于是字母，因此子节点就对应着26个小写字母)</li>
<li>布尔字段isEnd，表示该结点是否为字符串的结尾</li>
</ul>
<p>Trie树的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p>
<p>Trie树的基本性质：</p>
<ul>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串</li>
<li>每个节点的所有子节点包含的字符都不相同</li>
</ul>
<p><img src="/2021/10/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20211023192839278.png" alt="image-20211023192839278"></p>
<p>字典树的操作：</p>
<p><strong>插入字符串</strong></p>
<p>从字典树的根开始，插入字符串。对于当前对应的子节点，有两种情况</p>
<ul>
<li>子节点存在，沿着指针移动到子节点，继续处理下一个字符</li>
<li>子节点不存在，则创建一个新的子节点，记录children数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符</li>
</ul>
<p>重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的末尾</p>
<p><strong>查找前缀操作</strong></p>
<p>从字典树的根开始，查找前缀，同理对应当前字符串对应的子节点有两种情况：</p>
<ul>
<li>子节点存在，沿着指针移动到子节点，继续搜索下一个字符</li>
<li>子节点不存在，说明字典树当中不包含该前缀，因而也就不存在该前缀对应的所有字符</li>
</ul>
<p>重复以上步骤，直到返回空指针或者搜索完前缀的最后一个字符。若搜索到了前缀的末尾，说明字典树中存在该前缀。此外，若前缀末尾对应的isEnd为真，则说明字典树中存在该字符串。</p>
<h3 id="Trie树改进"><a href="#Trie树改进" class="headerlink" title="Trie树改进"></a>Trie树改进</h3><ul>
<li><p>按位Trie树（Bitwise Trie）：原理上和普通Trie树差不多，只不过普通Trie树存储的最小单位是字符，但是Bitwise Trie存放的是位而已。位数据的存取由CPU指令一次直接实现，对于二进制数据，它理论上要比普通Trie树快。</p>
</li>
<li><p>压缩节点</p>
<ul>
<li><p>分支压缩</p>
<p>对于稳定的Trie树，基本上都是查找和读取操作，完全可以把一些分支进行压缩，就是将某个前缀直接在压缩成一个节点</p>
</li>
<li><p>节点映射表</p>
<p>这种方式也是在Trie树的节点可能已经几乎完全确定的情况下采用的，针对Trie树中节点的每一个状态，如果状态总数重复很多的话，通过一个元素为数字的多维数组（比如Triple Array Trie）来表示，这样存储Trie树本身的空间开销会小一些，虽说引入了一张额外的映射表。</p>
</li>
</ul>
</li>
</ul>
<h2 id="6-摩尔投票法"><a href="#6-摩尔投票法" class="headerlink" title="6.摩尔投票法"></a>6.摩尔投票法</h2><p>给定一个长度为 <em>n</em> 的整数数组，找出其中所有出现超过 <code>⌊ n/3 ⌋</code> 次的元素。</p>
<p><img src="/2021/10/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20211023183617359.png" alt="image-20211023183617359"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">//摩尔投票法原理</span><br>        <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">0</span>, num2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> count1 = <span class="hljs-number">0</span>, count2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (count1 &gt; <span class="hljs-number">0</span> &amp;&amp; num == num1) &#123;<br>                count1 ++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count2 &gt; <span class="hljs-number">0</span> &amp;&amp; num == num2) &#123;<br>                count2 ++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count1 == <span class="hljs-number">0</span>) &#123;<br>                num1 = num;<br>                count1 = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count2 == <span class="hljs-number">0</span>) &#123;<br>                num2 = num;<br>                count2 = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                count1 --;<br>                count2 --;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//注意最后一定要检验是否满足条件</span><br>        <span class="hljs-keyword">int</span> cnt1 = <span class="hljs-number">0</span>, cnt2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (count1 &gt; <span class="hljs-number">0</span> &amp;&amp; num == num1) cnt1 ++;<br>            <span class="hljs-keyword">if</span> (count2 &gt; <span class="hljs-number">0</span> &amp;&amp; num == num2) cnt2 ++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt1 * <span class="hljs-number">3</span> &gt; nums.length) ans.add(num1);<br>        <span class="hljs-keyword">if</span> (cnt2 * <span class="hljs-number">3</span> &gt; nums.length) ans.add(num2);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="摩尔投票"><a href="#摩尔投票" class="headerlink" title="摩尔投票"></a>摩尔投票</h3><p>摩尔投票法：<strong>摩尔投票法的核心思想为对拼消耗</strong>。传统的投票问题就是使用摩尔投票选出票数最多的。每投一票看当前的人名，如果投的是当前人，则计数加1；如果投的不是当前的人名，则计数减一；当计数减为0的时候，对于下一个投票的人，将名换为他继续计数。如此重复，最终当投票数大于0最后记的人名即为得票数最多的。</p>
<p>先从简单的众数问题开始：</p>
<p>每次从序列里选择两个不相同的数字删除掉（或称为「抵消」），最后剩下一个数字或几个相同的数字，就是出现次数最多那个元素，然后检查该数出现次数是否大于n/2。</p>
<p><font face="楷体" color="FFD700">这道题也可以使用摩尔投票法，根据摩尔投票法的核心思想，每次选择三个互不相同的元素进行删除（或称为「抵消」）。可以假设数组中一定只存在一个次数大于n/3的元素 x，则此时可以把数组分成两部分：一部分相同的 k 个元素 x，另一部分为 (n-k)/3 组三个不同的元素，三个不同的元素会被抵消，因此最终只会剩下一个元素为 x。如果只存在 2 个次数大于的元素时，我们假设这两个不同的元素分别为 x 和 y，则此时我们一定可以把数组分成三部分：第一部分相同的 m 个元素 x，第二部分相同的 k 个元素 y，第三部分为(n-m-k)/3组三个互不同的元素，三个互不同的元素会被抵消，因此最终只会剩下两个元素为 x 和 y。这样得出的两个值不是一定满足大于n/3，需要进一步筛查验证。</font></p>
<p><strong>不失一般性的将其拓展为「统计出现次数超过 n / k 的数。</strong></p>
<p>显然，出现次数超过 n / k的数最多只有 k - 1个。当明确了符合要求的数的数量之后，就可以使用有限变量来代表这 k - 1个候选数及其出现次数。然后使用「摩尔投票」的标准做法，在遍历数组时同时 check 这 k - 1个数，假设当前遍历到的元素为 x：</p>
<ul>
<li>如果 x 本身是候选者的话，则对其出现次数加一；</li>
<li>如果 x 本身不是候选者，检查是否有候选者的出现次数为 0：<ul>
<li>若有，则让 xx 代替其成为候选者，并记录出现次数为 1；</li>
<li>若无，则让所有候选者的出现次数减一。</li>
</ul>
</li>
</ul>
<p>当处理完整个数组后，这 k - 1个数可能会被填满，但不一定都是符合出现次数超过 n / k 要求的。<strong>需要进行二次遍历</strong>，来确定候选者是否符合要求，将符合要求的数加到答案。</p>
<h2 id="7-记忆化搜索"><a href="#7-记忆化搜索" class="headerlink" title="7.记忆化搜索"></a>7.记忆化搜索</h2><p>在 LeetCode 商店中， 有 n 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。</p>
<p>给你一个整数数组 price 表示物品价格，其中 price[i] 是第 i 件物品的价格。另有一个整数数组 needs 表示购物清单，其中 needs[i] 是需要购买第 i 件物品的数量。</p>
<p>还有一个数组 special 表示大礼包，special[i] 的长度为 n + 1 ，其中 special[ i ] [ j ]表示第 i 个大礼包中内含第 j 件物品的数量，且 special[ i ] [n ]（也就是数组中的最后一个整数）为第 i 个大礼包的价格。</p>
<p>返回确切满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买</p>
<p><img src="/2021/10/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20211024174121649.png" alt="image-20211024174121649"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Map&lt;List&lt;Integer&gt;, Integer&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">shoppingOffers</span><span class="hljs-params">(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = price.size();<br>        <span class="hljs-comment">//过滤得出礼包价格能比单买有优惠的礼包</span><br>        List&lt;List&lt;Integer&gt;&gt; filter = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; sp : special) &#123;<br>            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, pri = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>                cnt += sp.get(i);<br>                pri += sp.get(i) * price.get(i);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">0</span> &amp;&amp; sp.get(n) &lt; pri) &#123;<br>                filter.add(sp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(price, needs, filter, n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;Integer&gt; price, List&lt;Integer&gt; curNeeds, List&lt;List&lt;Integer&gt;&gt; filter, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//记忆化搜索，免去重复进行的一些搜索</span><br>        <span class="hljs-keyword">if</span> (!m.containsKey(curNeeds)) &#123;<br>            <span class="hljs-keyword">int</span> min = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>                min += curNeeds.get(i) * price.get(i);<span class="hljs-comment">//不使用大礼包,单价购买</span><br>            &#125;<br>            <span class="hljs-keyword">for</span> (List&lt;Integer&gt; sp : filter) &#123;<br>                <span class="hljs-keyword">int</span> spcialPrice = sp.get(n);<br>                List&lt;Integer&gt; nextNeed = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//求出dfs下一次需要购买的清单</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>                    <span class="hljs-keyword">if</span> (sp.get(i) &gt; curNeeds.get(i)) <span class="hljs-keyword">break</span>;<br>                    nextNeed.add(curNeeds.get(i) - sp.get(i));<br>                &#125;<br>                <span class="hljs-keyword">if</span> (nextNeed.size() == n) &#123;<br>                    min = Math.min(min, dfs(price, nextNeed, filter, n) + spcialPrice);<span class="hljs-comment">//购买礼包的方式与单价购买的取最小值</span><br>                &#125;<br>            &#125;<br>            m.put(curNeeds, min);<br>        &#125;<br>        <span class="hljs-keyword">return</span> m.get(curNeeds);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p><font face="楷体" color="FFD700">记忆化搜索的思想是,在搜索过程中，会有很多重复计算,如果我们能记录一些状态的答案，就可以减少重复搜索量。动态规划虽然比较好地处理了重叠子问题，但是在有些拓扑关系比较复杂的题目面前，又显得无奈。记忆化搜索正是在这样的情况下产生的，它采用搜索的形式和动态规划中递推的思想将这两种方法有机地综合在一起。</font></p>
<p><strong>记忆化搜索=搜索的形式(深度、广度优先)+动态规划的思想</strong></p>
<h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>根据记忆化搜索的思想，其目的是解决重复计算的，也就是说搜索必须在搜索扩展路径的的过程中分步计算的，即搜索答案与路径相关的问题，而不是搜索一条路径之后才能计算的问题，而应该是分布计算的，在搜索过程中一个搜索结果必须可以建立在同类性问题的结果上，即是问题的子问题。解决问题不是单纯生成一个搜索走步方案，而是生成一个走步方案的代价等，而且每走一步，在搜索树/图中生成一个新状态，都可以精确计算出到此为止的费用，也就是，可以分步计算，这样才可以套用已经得到的答案</p>
<h3 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h3><p>a. 首先，要通过一个表记录已经存储下的搜索结果，一般用哈希表实现<br>b.状态表示，由于是要用哈希表实现，所以状态最好可以用数字表示，常用的方法是把一个状态连写成一个p进制数字，然后把这个数字对应的十进制数字作为状态<br>c.在每一状态搜索的开始，高效的使用哈希表搜索这个状态是否出现过，如果已经做过，直接调用答案，回溯<br>d.如果没有，则按正常方法搜索</p>
<div id="paginator"></div></div><p><strong>本文标题</strong>：每日一题<br><strong>本文作者</strong>：MaoZH<br><strong>本文链接</strong>：<a href="/2021/10/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">https://jack-edward.github.io/2021/10/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</a><br><strong>版权声明</strong>：转载或借鉴请注明出处，保留以上声明信息！</p><div class="post_share"><div class="social-share share-component" data-image="https://cdn.jsdelivr.net/gh/hassanblog/CDN/img/cover_character_drawing.png" data-sites="facebook,twitter,wechat,weibo,qq,qzone,tencent,douban,diandian,google,linkedin"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="all" onload="this.media=&quot;all&quot;"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer=""></script></div><div id="post-footer"><hr><a href="/2021/10/16/spark%E5%9F%BA%E7%A1%80/">spark基础 Next →</a><hr></div><div id="bottom-btn"><a id="to-index" href="#post-index" title="index">≡</a><a id="to-top" href="#post-title" title="to top">∧</a></div><div id="Valine"></div><script>new Valine({
 el: '#Valine'
 , appId: 'TWFe26C7GQDWyvw3lVpQUswj-gzGzoHsz'
 , appKey: 'kA8WG8bPJQ16UwOnhf7TGdHn'
 , placeholder: '欢迎大家评论，感谢批评指正'
})</script></div></article><aside><form><div class="tipue_search_group"><input id="tipue_search_input" type="text" name="q" placeholder="Search Here" pattern=".{3,}" title="At least 3 characters" autofocus="autofocus" required=""><button class="tipue_search_button" type="submit"><div class="tipue_search_icon">⚲</div></button></div></form><div id="tipue_search_content"></div><script>$(document).ready(function() {
$('#tipue_search_input').tipuesearch();
});</script><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><div id="he-plugin-standard"></div><script>WIDGET = {
"CONFIG": {
"layout": "1",
"width": 450,
"height": 150,
"background": "3",
"dataColor": "FFFFFF",
"key": "e2043117ad6d459bb0eb89b26de1b4a2"
}
}</script><script src="https://widget.qweather.net/standard/static/js/he-standard-common.js?v=2.0"></script><h1 id="dr"><a href="/"> Mr.MaoZH</a></h1><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">7</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">8</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">3</span></div></section></div><div id="about-me"><span class="about-me">Contact-me:</span><a href="tencent://message/?uin=3128633651&amp;amp;site=qq&amp;amp;menu=yes"><img src="https://im.qq.com/favicon.ico"></a><a href="mailto:3128633651@qq.com"><img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/email.svg" width="20"></a></div><div id="aside-block"><div id="aside"><h1>INDEX</h1><div id="post-index"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BA%8C%E5%88%86%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">1.二分法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">2.</span> <span class="toc-text">2.并查集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%80%92%E5%BD%92"><span class="toc-number">3.</span> <span class="toc-text">3.递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">4.回溯法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">4.1.</span> <span class="toc-text">回溯法总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%90%E9%9B%86%E6%A0%91%E4%B8%8E%E6%8E%92%E5%88%97%E6%A0%91"><span class="toc-number">4.1.2.</span> <span class="toc-text">2.子集树与排列树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.3.</span> <span class="toc-text">3.回溯法实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AD%97%E5%85%B8%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">5.字典树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Trie%E6%A0%91"><span class="toc-number">5.1.</span> <span class="toc-text">Trie树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trie%E6%A0%91%E6%94%B9%E8%BF%9B"><span class="toc-number">5.2.</span> <span class="toc-text">Trie树改进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">6.摩尔投票法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8"><span class="toc-number">6.1.</span> <span class="toc-text">摩尔投票</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-number">7.</span> <span class="toc-text">7.记忆化搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E6%83%B3"><span class="toc-number">7.1.</span> <span class="toc-text">思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">7.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.3.</span> <span class="toc-text">核心实现</span></a></li></ol></li></ol></div><div id="post-index"></div></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">2020 to 2021</span></nobr><wbr><nobr><span class="text-title">ICP</span><span class="text-content">——备案号——</span></nobr><wbr><wbr><nobr>published with&nbsp;<a href="https://jack-edward.github.io">Zhihui Mao&nbsp;</a></nobr><wbr><nobr>Theme&nbsp;<a href="">Arknight&nbsp;</a></nobr><wbr><nobr>by&nbsp;<a href="">Yue_plus </a></nobr><wbr><script type="text/javascript" src="jquery.min.js"></script><script type="text/javascript">$(document).ready(function(){
//通过调用新浪IP地址库接口查询用户当前所在国家、省份、城市、运营商信息
$.getScript('https://pv.sohu.com/cityjson?ie=utf-8',function(){
$(".city").html(returnCitySN.cname);
$(".ip").html(returnCitySN.cip);
//$(".browser").html(navigator.appVersion);
});
});</script></footer><div>欢迎来自<span class="city"></span>地区的朋友<br>您的IP地址为：<span class="ip"></span><!--| <br>您的浏览器为：--><!--span.browser--><wbr><script type="text/javascript" src="//rf.revolvermaps.com/0/0/1.js?i=52al2pyccg1&amp;s=216&amp;m=0&amp;v=true&amp;r=false&amp;b=000000&amp;n=false&amp;c=ff0000" async="async"></script><wbr><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=406086764&auto=0&height=66"></iframe></div></aside></main><canvas id="canvas-dust"></canvas><script src="/js/arknights.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script></body></html>