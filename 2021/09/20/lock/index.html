<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>lock | MaoZH</title><script src="https://cdn.bootcss.com/valine/1.4.4/Valine.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/mermaid/8.11.0/mermaid.min.js"></script><script>mermaid.initialize({
  startOnLoad: true
  , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="MaoZH" type="application/atom+xml">
</head><body><header><nav><a href="/">Home</a><a href="/archives/">Archives</a></nav></header><main><article><div id="post-bg"><div id="post-title"><h1>lock</h1><hr></div><div id="post-content"><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p>==Java对象头==</p>
<p>普通对象</p>
<pre><code class="ruby">|--------------------------------------------------------------|
|                     Object Header (64 bits)                    |
|------------------------------------|-------------------------|
| Mark Word (32 bits)                  | Klass Word (32 bits)    |
|------------------------------------|-------------------------|
</code></pre>
<p>数组对象</p>
<pre><code class="ruby">|---------------------------------------------------------------------------------|
|                             Object Header (96 bits)                               |
|--------------------------------|-----------------------|------------------------|
| Mark Word(32bits)              | Klass Word(32bits)      | array length(32bits)   |
|--------------------------------|-----------------------|------------------------|
</code></pre>
<p>其中MarkWord结构如下</p>
<pre><code class="ruby">|-------------------------------------------------------|--------------------|
|                 Mark Word (32 bits)                     |         State          |
|-------------------------------------------------------|--------------------|
| hashcode:25           | age:4 | biased_lock:0 | 01         |         Normal          |
|-------------------------------------------------------|--------------------|
| thread:23 | epoch:2 | age:4 | biased_lock:1 | 01         |         Biased          |
|-------------------------------------------------------|--------------------|
|             ptr_to_lock_record:30               | 00         | Lightweight Locked |
|-------------------------------------------------------|--------------------|
|         ptr_to_heavyweight_monitor:30           | 10         | Heavyweight Locked |
|-------------------------------------------------------|--------------------|
|                                               | 11         |     Marked for GC    |
|-------------------------------------------------------|--------------------|
</code></pre>
<p>64位虚拟机MarkWord</p>
<pre><code class="ruby">|--------------------------------------------------------------------|------------------|
|                         Mark Word (64 bits)                          |         State         |
|--------------------------------------------------------------------|------------------|
| unused:25 | hashcode:31 | unused:1 | age:4 | biased_lock:0 | 01      |         Normal         |
|--------------------------------------------------------------------|------------------|
| thread:54     | epoch:2 | unused:1 | age:4 | biased_lock:1 | 01      |         Biased         |
|--------------------------------------------------------------------|------------------|
|                         ptr_to_lock_record:62                  | 00    |Lightweight Locked|
|--------------------------------------------------------------------|------------------|
|                         ptr_to_heavyweight_monitor:62          | 10    |Heavyweight Locked|
|--------------------------------------------------------------------|------------------|
|                                                              | 11      |   Marked for GC  |
|--------------------------------------------------------------------|------------------|
</code></pre>
<p>比如：一个Integer对象的对象头是8byte，一个int为4byte，一个Integer对象内含一个int值总共12byte</p>
<p>参考博客：<a target="_blank" rel="noopener" href="https://blog.dreamtobe.cn/2015/11/13/java_synchronized/">https://blog.dreamtobe.cn/2015/11/13/java_synchronized/</a></p>
<p>==Monitor锁(JVM层面)==</p>
<p>Monitor称为监视器或管程</p>
<p>每个Java对象都可以关联一个Monitor对象，当使用synchronized给对象上重量级锁后，该对象头的MarkWord中</p>
<p><img src="/.com//image-20210915225138608-1632143620306.png" alt="image-20210915225138608"></p>
<p><img src="/.com//image-20210915224600836-1632143620306.png" alt="image-20210915224600836"></p>
<p>相应对象的对象头将会记录该Monitor锁的地址</p>
<p>1.起初 Monitor 中 Owner 为 null</p>
<p>2.当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一 个 Owner</p>
<p>3.在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList 处于BLOCKED状态</p>
<p>4.Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的</p>
<p>5.WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会分析</p>
<p>==字节码看synchronized原理==</p>
<pre><code class="java">static final Object lock = new Object();
static int counter = 0;
public static void main(String[] args) &#123;
 synchronized (lock) &#123;
 counter++;
 &#125;
&#125;
</code></pre>
<p>反编译产生的字节码</p>
<pre><code class="java">public static void main(java.lang.String[]);
 descriptor: ([Ljava/lang/String;)V
 flags: ACC_PUBLIC, ACC_STATIC
 Code:
     stack=2, locals=3, args_size=1
     0: getstatic #2 // &lt;- lock引用 （synchronized开始）
     3: dup
     4: astore_1 // lock引用 -&gt; slot 1
     5: monitorenter // 将 lock对象 MarkWord 置为 Monitor 指针
     6: getstatic #3 // &lt;- i
     9: iconst_1 // 准备常数 1
     10: iadd // +1
     11: putstatic #3 // -&gt; i
     14: aload_1 // &lt;- lock引用
     15: monitorexit // 将 lock对象 MarkWord 重置, 唤醒 EntryList
     16: goto 24
     //抛出异常时执行，同样释放锁还原markword
     19: astore_2 // e -&gt; slot 2
     20: aload_1 // &lt;- lock引用
     21: monitorexit // 将 lock对象 MarkWord 重置, 唤醒 EntryList
     22: aload_2 // &lt;- slot 2 (e)
     23: athrow // throw e
     24: return
     Exception table:
     from to target type
     6 16 19 any
     19 22 19 any
     LineNumberTable:
     line 8: 0
     line 9: 6
     line 10: 14
     line 11: 24
     LocalVariableTable:
     Start Length Slot Name Signature
     0 25 0 args [Ljava/lang/String;
     StackMapTable: number_of_entries = 2
     frame_type = 255 /* full_frame */
     offset_delta = 19
     locals = [ class &quot;[Ljava/lang/String;&quot;, class java/lang/Object ]
     stack = [ class java/lang/Throwable ]
     frame_type = 250 /* chop */
     offset_delta = 4
</code></pre>
<p>注意：方法级别的Synchronized不会在字节码指令中体现</p>
<h2 id="Synchronized-进阶"><a href="#Synchronized-进阶" class="headerlink" title="Synchronized 进阶"></a>Synchronized 进阶</h2><p><strong>1.轻量级锁</strong></p>
<p>当一个对象被多个线程使用，多个线程对其加锁的时间是错开的(没有竞争)，此时采用轻量级锁</p>
<p>轻量级锁的实现封装在Synchronized 中</p>
<pre><code class="java">//以这段代码为例看加锁流程
static final Object obj = new Object();
public static void method1() &#123;
         synchronized( obj ) &#123;
         // 同步块 A
         method2();
     &#125;
&#125;
public static void method2() &#123;
         synchronized( obj ) &#123;
         // 同步块 B
     &#125;
&#125;
</code></pre>
<p>1.Thread0线程创建锁记录LockRecord对象(JVM层面)，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</p>
<p><img src="/.com//image-20210915231340226-1632143620307.png" alt="image-20210915231340226"></p>
<p>2.当synchronized加锁时，锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p>
<p><img src="/.com//image-20210915231455686-1632143620307.png" alt="image-20210915231455686"></p>
<p>3.若CAS替换成功，对象头中存储了锁记录地址以及轻量级加锁状态00，表示由该线程给对象加锁，原来锁记录的锁记录地址就变为对象头的markword记录对象的hashcode,分代年龄偏向状态以及加锁状态</p>
<p><img src="/.com//image-20210915231836547-1632143620307.png" alt="image-20210915231836547"></p>
<p>4.如果CAS失败，分两种情况</p>
<ul>
<li><p>1.如果是自己执行了synchronized 锁重入，那么该线程栈帧新添加一个锁记录，此时CAS发现加锁状态已经是00轻量锁的状态，CAS失败，但是由于锁已经绑定当前线程的另一条锁记录，此时锁记录置为Null并且会将锁重入的计数加1</p>
<p><img src="/.com//image-20210915232801386-1632143620307.png" alt="image-20210915232801386"><br>2.当退出 synchronized 代码块时，如果是取值为 null 的锁记录，表示有锁重入，这时清除锁记录，表示重入计数减1</p>
</li>
<li><p>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</p>
</li>
</ul>
<p>5.当退出 synchronized 代码块时，如果锁记录的值不为null，这时使用CAS将对象头当中的MarkWord恢复，即还原原来的hashcode,分代年龄偏向状态以及加锁状态。</p>
<p>6.如果操作成功，解锁成功；如果失败，说明轻量级锁进行了锁膨胀或者已经升级为重量级锁，进入重量级锁解锁流程</p>
<p><strong>2.锁膨胀</strong></p>
<p>在尝试加轻量级锁过程中，CAS操作无法成功，一种情况就是有其他线程对此对象已经加上了轻量级锁，这时会发生锁膨胀，轻量级锁变为重量级锁</p>
<pre><code class="java">//Thread1
static Object obj = new Object();
public static void method1() &#123;
     synchronized( obj ) &#123;
     // 同步块
     &#125;
&#125;
</code></pre>
<p>1.当另一个线程Thread1要加轻量级锁时，但是此时Thread0已经对该对象加了轻量级锁，此时进行CAS时失败</p>
<p><img src="/.com//image-20210915234209725-1632143620307.png" alt="image-20210915234209725"></p>
<p>2.Thread1加轻量级锁失败，进入锁膨胀流程</p>
<ul>
<li>为加锁对象Object申请Monitor锁，该对象的对象头的MarkWord变为指向重量级锁Monitor的地址Thread进入到Monitor对象的EntryList当中进入阻塞等待状态，同时Monitor的Owner会指向当前Thread0的锁记录</li>
</ul>
<p><img src="/.com//image-20210915235307588-1632143620307.png" alt="image-20210915235307588"></p>
<p>3.当Thread0退出同步锁解锁时，由于锁已经升级为重量级锁状态，使用CAS恢复MarkWord失败，此时进入重量级锁解锁流程：</p>
<p>先按照Monitor地址找到Monitor对象，将Owner置为空，唤醒EntryList当中的线程，让其中一个线程获得该对象的重量级锁；当没有线程加锁时Monitor地址将变为最后一个锁记录的地址，最后进行CAS恢复对象头MarkWord</p>
<img src="/.com//Users/hasee/Desktop/note/image/1631721641280.jpg.jpg" alt="1631721641280.jpg" style="zoom:150%;">

<p><strong>自旋优化</strong></p>
<p>重量级锁竞争时可以使用自旋(在有线程占用锁的时候其他线程进行循环尝试加锁)来进行优化，如果当前线程自选成功，可以避免当前线程阻塞(阻塞会发生上下文切换，耗费资源)，充分利用cpu资源</p>
<p>==自选加锁成功==</p>
<p><img src="/.com//image-20210916225247972-1632143620307.png" alt="image-20210916225247972"></p>
<p>==自旋加锁失败==</p>
<p><img src="/.com//image-20210916225315806-1632143620307.png" alt="image-20210916225315806"></p>
<p>自旋能够充分提升多核cpu的效率，在java6后自旋锁是自适应的，比如对象刚刚一次自旋操作成功则认为这次自旋成功的可能性高，会多进行几次自旋；反之就少自旋甚至不自旋</p>
<p><strong>3.偏向锁</strong></p>
<p>轻量级锁在没有竞争时（本身线程），每次重入仍然需要执行 CAS 操作。<br>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现 这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p>
<pre><code class="java">static final Object obj = new Object();
public static void m1() &#123;
     synchronized( obj ) &#123;
         // 同步块 A
         m2();
     &#125;
&#125;
public static void m2() &#123;
     synchronized( obj ) &#123;
         // 同步块 B
         m3();
     &#125;
&#125;
public static void m3() &#123;
     synchronized( obj ) &#123;
          // 同步块 C
     &#125;
&#125;
</code></pre>
<p><img src="/.com//image-20210916230912193-1632143620307.png" alt="image-20210916230912193"></p>
<p>使用偏向锁后就不需要CAS操作，直接判断线程ID</p>
<p><img src="/.com//image-20210916230854627-1632143620307.png" alt="image-20210916230854627"></p>
<p>==偏向状态==</p>
<p>对象创建时：</p>
<ul>
<li>默认开启偏向锁，对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 thread、epoch、age 都为 0</li>
<li>偏向锁是默认是延迟的，不会在程序启动时立即生效，可以加VM参数==-XX:BiasedLockingStartupDelay=0==禁用延迟</li>
</ul>
<p>使用jol第三方工具读取markword的值，用于测试</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;
    &lt;artifactId&gt;jol-core&lt;/artifactId&gt;
    &lt;version&gt;0.16&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>1)延迟特性</p>
<p>2)偏向锁</p>
<pre><code class="java">public class TestBiased &#123;
    public static void main(String[] args) &#123;
        Lock lock = new Lock();
        new Thread(() -&gt; &#123;
            System.out.println(&quot;synchronized前&quot;);
            System.out.println(ClassLayout.parseInstance(lock).toPrintable());
            synchronized (lock) &#123;
                System.out.println(&quot;synchronized中&quot;);
                System.out.println(ClassLayout.parseInstance(lock).toPrintable());
            &#125;
            System.out.println(&quot;synchronized后&quot;);
            System.out.println(ClassLayout.parseInstance(lock).toPrintable());
        &#125;,&quot;t1&quot;).start();
    &#125;
&#125;
class Lock&#123;

&#125;
</code></pre>
<p><img src="/.com//image-20210916232830431-1632143620307.png" alt="image-20210916232830431"></p>
<p>处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</p>
<p>3)禁用</p>
<p>通过添加VM参数-XX:-UseBiasedLocking禁用偏向锁</p>
<p><img src="/.com//image-20210916233239252-1632143620307.png" alt="image-20210916233239252"></p>
<p>4)调用hashcode也会禁用偏向锁</p>
<p>正常状态对象一开始是没有 hashCode 的，第一次调用才生成，上述代码调用hashcode就会禁用偏向锁</p>
<p>原因：hashcode在markword占用31位，使用偏向锁后无法存入hashcode</p>
<blockquote>
<p>撤销-调用对象的hashCode</p>
</blockquote>
<p>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，没有多余的空间存储hashcode，如果调用 hashCode 会导致偏向锁被撤销，转而使用轻量锁</p>
<ul>
<li>轻量级锁会在锁记录中记录hashcode</li>
<li>重量级锁会在monitor中记录hashcode</li>
</ul>
<blockquote>
<p>撤销-其他线程对该对象加锁</p>
</blockquote>
<pre><code class="java">public class TestBiased2 &#123;
    public static void main(String[] args) &#123;
        Lock lock = new Lock();
        new Thread(() -&gt; &#123;
            synchronized (lock) &#123;
                System.out.println(ClassLayout.parseInstance(lock).toPrintable());//0101
            &#125;
            synchronized (TestBiased2.class) &#123;
                TestBiased2.class.notify();
            &#125;
        &#125;).start();
        new Thread(() -&gt; &#123;
            synchronized (TestBiased2.class) &#123;
                try &#123;
                    TestBiased2.class.wait();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                System.out.println(ClassLayout.parseInstance(lock).toPrintable());//0101
                synchronized (lock) &#123;
                    System.out.println(ClassLayout.parseInstance(lock).toPrintable());//0000,解除偏向锁
                &#125;
                System.out.println(ClassLayout.parseInstance(lock).toPrintable());//0001
            &#125;
        &#125;,&quot;t2&quot;).start();
    &#125;
&#125;
</code></pre>
<p><img src="/.com//image-20210916234915082-1632143620307.png"></p>
<p>当有其它线程使用该对象对其加锁时，偏向锁会撤销变为轻量级锁</p>
<blockquote>
<p>撤销-调用wait/notify</p>
</blockquote>
<p>因为wait/notify使用时是在重量级锁下的，肯定会撤销偏向锁</p>
<p>==批量重偏向==</p>
<p>对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象 的 Thread ID，当撤销偏向锁阈值超过20次后JVM会认为目前的偏向状态是错误的，于是会在给这些对象加锁时重新偏向至加锁线程</p>
<pre><code class="java">public class TestBiased3 &#123;
    public static void main(String[] args) &#123;
        Vector&lt;Lock&gt; list = new Vector&lt;&gt;();
        new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 30; i++) &#123;//从i=0开始就偏向线程t1了,1000
                Lock lock = new Lock();
                System.out.println(i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable());
                list.add(lock);
                synchronized (lock) &#123;
                    System.out.println(i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable());
                &#125;
            &#125;
            synchronized (list) &#123;
                list.notify();
            &#125;
        &#125;, &quot;t1&quot;).start();

        new Thread(() -&gt; &#123;
            synchronized (list) &#123;
                try &#123;
                    list.wait();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            System.out.println(&quot;==========================&quot;);
            for (int i = 0; i &lt; 30; i++) &#123;//前19个都是将偏向锁依然偏向t1,第20个及以后改为偏向t2
                Lock lock = list.get(i);
                System.out.println(i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable());
                synchronized (lock) &#123;
                    System.out.println(i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable());
                &#125;
                System.out.println(i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable());
            &#125;
        &#125;, &quot;t2&quot;).start();
    &#125;
&#125;
</code></pre>
<p>线程t1加锁时处于偏向状态，偏向t1线程</p>
<p><img src="/.com//image-20210917000118919-1632143620307.png" alt="image-20210917000118919"></p>
<p>当线程t2刚开始对该对象加锁时，对象的偏向状态依然是偏向线程t1的，此时t2线程对对象加锁为轻量级锁</p>
<p><img src="/.com//image-20210917000458627-1632143620308.png" alt="image-20210917000458627"></p>
<p>当撤销锁达到20次时，会改变偏向状态</p>
<p><img src="/.com//image-20210917000646372-1632143620308.png" alt="image-20210917000646372"></p>
<p>==批量撤销==</p>
<p>当撤销偏向锁阈值超过 40 次后，jvm 会这样认为确实偏向错了，此时该对象的使用竞争太激烈，根本就不该偏向。于是整个类的所有对象 都会变为不可偏向的，新建的对象也是不可偏向的</p>
<pre><code class="java">public class TestBiased4 &#123;
    static Thread t1, t2, t3;

    public static void main(String[] args) throws InterruptedException &#123;
        test4();
    &#125;
    private static void test4() throws InterruptedException &#123;
        Vector&lt;Lock&gt; list = new Vector&lt;&gt;();
        int loopNumber = 39;
        t1 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; loopNumber; i++) &#123;
                Lock lock = new Lock();
                list.add(lock);
                synchronized (lock) &#123;
                    System.out.println((i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable()));
                &#125;
            &#125;
            LockSupport.unpark(t2);
        &#125;, &quot;t1&quot;);
        t1.start();
        t2 = new Thread(() -&gt; &#123;
            LockSupport.park();
            System.out.println((&quot;================ &quot;));
            for (int i = 0; i &lt; loopNumber; i++) &#123;
                Lock lock = list.get(i);
                System.out.println((i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable()));
                synchronized (lock) &#123;
                    System.out.println((i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable()));
                &#125;
                System.out.println((i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable()));
            &#125;
            LockSupport.unpark(t3);
        &#125;, &quot;t2&quot;);
        t2.start();
        t3 = new Thread(()-&gt; &#123;
            LockSupport.park();
            System.out.println(&quot;=================&quot;);
            for (int i = 0; i &lt; loopNumber; i++) &#123;
                Lock lock = list.get(i);
                System.out.println((i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable()));
                synchronized (lock) &#123;
                    System.out.println((i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable()));
                &#125;
                System.out.println((i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable()));
            &#125;
        &#125;, &quot;t3&quot;);
        t3.start();
        t3.join();
        System.out.println((ClassLayout.parseInstance(new Lock()).toPrintable()));
    &#125;
&#125;
</code></pre>
<p><img src="/.com//image-20210917001758215-1632143620308.png" alt="image-20210917001758215"></p>
<p>update</p>
<div id="paginator"></div></div><div id="post-footer"><hr><a href="/2021/09/20/Lock-0/">← Prev Lock</a><span style="color: #fe2"> | </span><a href="/2021/09/20/hello-world/">Hello World Next →</a><hr></div><div id="bottom-btn"><a id="to-index" href="#post-index" title="index">≡</a><a id="to-top" href="#post-title" title="to top">∧</a></div><div id="Valine"></div><script>new Valine({
 el: '#Valine'
 , appId: ''
 , appKey: ''
 , placeholder: '此条评论委托企鹅物流发送'
})</script></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="dr"><a href="/"> Mr.MaoZH</a></h1><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">4</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">3</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">1</span></div></section></div><div id="aside-block"><h1>INDEX</h1><div id="post-index"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">锁机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronized-%E8%BF%9B%E9%98%B6"><span class="toc-number">2.</span> <span class="toc-text">Synchronized 进阶</span></a></li></ol></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">2020 to 2021</span></nobr><wbr><nobr><span class="text-title">ICP</span><span class="text-content">——备案号——</span></nobr><wbr><wbr><nobr>published with&nbsp;<a target="_blank" rel="noopener" href="http://hexo.io">Zhihui Mao&nbsp;</a></nobr><wbr><nobr>Theme&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight&nbsp;</a></nobr><wbr><nobr>by&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/arknights.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script></body></html>