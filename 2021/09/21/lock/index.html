<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification"><title>lock | MaoZH</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><link rel="stylesheet" type="text/css" href="/plugins/highlight/atom-one-dark.min.css"><script type="text/javascript" src="/plugins/highlight/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();
</script><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">MaoZH</a></h1></div><p class="m-desc">心之所向，无惧无悔,<br>既然选择远方，便只顾风雨兼程！</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">lock</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2021/09/21/lock/">2021-09-21</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/Java/">Java</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p>==Java对象头==</p>
<p>普通对象</p>
<pre><code class="ruby">|--------------------------------------------------------------|
|                     Object Header (64 bits)                    |
|------------------------------------|-------------------------|
| Mark Word (32 bits)                  | Klass Word (32 bits)    |
|------------------------------------|-------------------------|
</code></pre>
<p>数组对象</p>
<pre><code class="ruby">|---------------------------------------------------------------------------------|
|                             Object Header (96 bits)                               |
|--------------------------------|-----------------------|------------------------|
| Mark Word(32bits)              | Klass Word(32bits)      | array length(32bits)   |
|--------------------------------|-----------------------|------------------------|
</code></pre>
<p>其中MarkWord结构如下</p>
<pre><code class="ruby">|-------------------------------------------------------|--------------------|
|                 Mark Word (32 bits)                     |         State          |
|-------------------------------------------------------|--------------------|
| hashcode:25           | age:4 | biased_lock:0 | 01         |         Normal          |
|-------------------------------------------------------|--------------------|
| thread:23 | epoch:2 | age:4 | biased_lock:1 | 01         |         Biased          |
|-------------------------------------------------------|--------------------|
|             ptr_to_lock_record:30               | 00         | Lightweight Locked |
|-------------------------------------------------------|--------------------|
|         ptr_to_heavyweight_monitor:30           | 10         | Heavyweight Locked |
|-------------------------------------------------------|--------------------|
|                                               | 11         |     Marked for GC    |
|-------------------------------------------------------|--------------------|
</code></pre>
<p>64位虚拟机MarkWord</p>
<pre><code class="ruby">|--------------------------------------------------------------------|------------------|
|                         Mark Word (64 bits)                          |         State         |
|--------------------------------------------------------------------|------------------|
| unused:25 | hashcode:31 | unused:1 | age:4 | biased_lock:0 | 01      |         Normal         |
|--------------------------------------------------------------------|------------------|
| thread:54     | epoch:2 | unused:1 | age:4 | biased_lock:1 | 01      |         Biased         |
|--------------------------------------------------------------------|------------------|
|                         ptr_to_lock_record:62                  | 00    |Lightweight Locked|
|--------------------------------------------------------------------|------------------|
|                         ptr_to_heavyweight_monitor:62          | 10    |Heavyweight Locked|
|--------------------------------------------------------------------|------------------|
|                                                              | 11      |   Marked for GC  |
|--------------------------------------------------------------------|------------------|
</code></pre>
<p>比如：一个Integer对象的对象头是8byte，一个int为4byte，一个Integer对象内含一个int值总共12byte</p>
<p>参考博客：<a target="_blank" rel="noopener" href="https://blog.dreamtobe.cn/2015/11/13/java_synchronized/">https://blog.dreamtobe.cn/2015/11/13/java_synchronized/</a></p>
<p>==Monitor锁(JVM层面)==</p>
<p>Monitor称为监视器或管程</p>
<p>每个Java对象都可以关联一个Monitor对象，当使用synchronized给对象上重量级锁后，该对象头的MarkWord中</p>
<p><img src="/2021/09/21/lock/image-20210915225138608.png" alt="image-20210915225138608"></p>
<p><img src="/2021/09/21/lock/image-20210915224600836.png" alt="image-20210915224600836"></p>
<p>相应对象的对象头将会记录该Monitor锁的地址</p>
<p>1.起初 Monitor 中 Owner 为 null</p>
<p>2.当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一 个 Owner</p>
<p>3.在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList 处于BLOCKED状态</p>
<p>4.Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的</p>
<p>5.WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会分析</p>
<p>==字节码看synchronized原理==</p>
<pre><code class="java">static final Object lock = new Object();
static int counter = 0;
public static void main(String[] args) &#123;
 synchronized (lock) &#123;
 counter++;
 &#125;
&#125;
</code></pre>
<p>反编译产生的字节码</p>
<pre><code class="java">public static void main(java.lang.String[]);
 descriptor: ([Ljava/lang/String;)V
 flags: ACC_PUBLIC, ACC_STATIC
 Code:
     stack=2, locals=3, args_size=1
     0: getstatic #2 // &lt;- lock引用 （synchronized开始）
     3: dup
     4: astore_1 // lock引用 -&gt; slot 1
     5: monitorenter // 将 lock对象 MarkWord 置为 Monitor 指针
     6: getstatic #3 // &lt;- i
     9: iconst_1 // 准备常数 1
     10: iadd // +1
     11: putstatic #3 // -&gt; i
     14: aload_1 // &lt;- lock引用
     15: monitorexit // 将 lock对象 MarkWord 重置, 唤醒 EntryList
     16: goto 24
     //抛出异常时执行，同样释放锁还原markword
     19: astore_2 // e -&gt; slot 2
     20: aload_1 // &lt;- lock引用
     21: monitorexit // 将 lock对象 MarkWord 重置, 唤醒 EntryList
     22: aload_2 // &lt;- slot 2 (e)
     23: athrow // throw e
     24: return
     Exception table:
     from to target type
     6 16 19 any
     19 22 19 any
     LineNumberTable:
     line 8: 0
     line 9: 6
     line 10: 14
     line 11: 24
     LocalVariableTable:
     Start Length Slot Name Signature
     0 25 0 args [Ljava/lang/String;
     StackMapTable: number_of_entries = 2
     frame_type = 255 /* full_frame */
     offset_delta = 19
     locals = [ class &quot;[Ljava/lang/String;&quot;, class java/lang/Object ]
     stack = [ class java/lang/Throwable ]
     frame_type = 250 /* chop */
     offset_delta = 4
</code></pre>
<p>注意：方法级别的Synchronized不会在字节码指令中体现</p>
<h2 id="Synchronized-进阶"><a href="#Synchronized-进阶" class="headerlink" title="Synchronized 进阶"></a>Synchronized 进阶</h2><p><strong>1.轻量级锁</strong></p>
<p>当一个对象被多个线程使用，多个线程对其加锁的时间是错开的(没有竞争)，此时采用轻量级锁</p>
<p>轻量级锁的实现封装在Synchronized 中</p>
<pre><code class="java">//以这段代码为例看加锁流程
static final Object obj = new Object();
public static void method1() &#123;
         synchronized( obj ) &#123;
         // 同步块 A
         method2();
     &#125;
&#125;
public static void method2() &#123;
         synchronized( obj ) &#123;
         // 同步块 B
     &#125;
&#125;
</code></pre>
<p>1.Thread0线程创建锁记录LockRecord对象(JVM层面)，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</p>
<p><img src="/2021/09/21/lock/image-20210915231340226.png" alt="image-20210915231340226"></p>
<p>2.当synchronized加锁时，锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p>
<p><img src="/2021/09/21/lock/image-20210915231455686.png" alt="image-20210915231455686"></p>
<p>3.若CAS替换成功，对象头中存储了锁记录地址以及轻量级加锁状态00，表示由该线程给对象加锁，原来锁记录的锁记录地址就变为对象头的markword记录对象的hashcode,分代年龄偏向状态以及加锁状态</p>
<p><img src="/2021/09/21/lock/image-20210915231836547.png" alt="image-20210915231836547"></p>
<p>4.如果CAS失败，分两种情况</p>
<ul>
<li><p>1.如果是自己执行了synchronized 锁重入，那么该线程栈帧新添加一个锁记录，此时CAS发现加锁状态已经是00轻量锁的状态，CAS失败，但是由于锁已经绑定当前线程的另一条锁记录，此时锁记录置为Null并且会将锁重入的计数加1</p>
<p><img src="/2021/09/21/lock/image-20210915232801386.png" alt="image-20210915232801386"><br>2.当退出 synchronized 代码块时，如果是取值为 null 的锁记录，表示有锁重入，这时清除锁记录，表示重入计数减1</p>
</li>
<li><p>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</p>
</li>
</ul>
<p>5.当退出 synchronized 代码块时，如果锁记录的值不为null，这时使用CAS将对象头当中的MarkWord恢复，即还原原来的hashcode,分代年龄偏向状态以及加锁状态。</p>
<p>6.如果操作成功，解锁成功；如果失败，说明轻量级锁进行了锁膨胀或者已经升级为重量级锁，进入重量级锁解锁流程</p>
<p><strong>2.锁膨胀</strong></p>
<p>在尝试加轻量级锁过程中，CAS操作无法成功，一种情况就是有其他线程对此对象已经加上了轻量级锁，这时会发生锁膨胀，轻量级锁变为重量级锁</p>
<pre><code class="java">//Thread1
static Object obj = new Object();
public static void method1() &#123;
     synchronized( obj ) &#123;
     // 同步块
     &#125;
&#125;
</code></pre>
<p>1.当另一个线程Thread1要加轻量级锁时，但是此时Thread0已经对该对象加了轻量级锁，此时进行CAS时失败</p>
<p><img src="/2021/09/21/lock/image-20210915234209725.png" alt="image-20210915234209725"></p>
<p>2.Thread1加轻量级锁失败，进入锁膨胀流程</p>
<ul>
<li>为加锁对象Object申请Monitor锁，该对象的对象头的MarkWord变为指向重量级锁Monitor的地址Thread进入到Monitor对象的EntryList当中进入阻塞等待状态，同时Monitor的Owner会指向当前Thread0的锁记录</li>
</ul>
<p><img src="/2021/09/21/lock/image-20210915235307588.png" alt="image-20210915235307588"></p>
<p>3.当Thread0退出同步锁解锁时，由于锁已经升级为重量级锁状态，使用CAS恢复MarkWord失败，此时进入重量级锁解锁流程：</p>
<p>先按照Monitor地址找到Monitor对象，将Owner置为空，唤醒EntryList当中的线程，让其中一个线程获得该对象的重量级锁；当没有线程加锁时Monitor地址将变为最后一个锁记录的地址，最后进行CAS恢复对象头MarkWord</p>
<img src="/2021/09/21/lock/1631721641280.jpg.jpg" alt="1631721641280.jpg" style="zoom:150%;">

<p><strong>自旋优化</strong></p>
<p>重量级锁竞争时可以使用自旋(在有线程占用锁的时候其他线程进行循环尝试加锁)来进行优化，如果当前线程自选成功，可以避免当前线程阻塞(阻塞会发生上下文切换，耗费资源)，充分利用cpu资源</p>
<p>==自选加锁成功==</p>
<p><img src="/2021/09/21/lock/image-20210916225247972.png" alt="image-20210916225247972"></p>
<p>==自旋加锁失败==</p>
<p><img src="/2021/09/21/lock/image-20210916225315806.png" alt="image-20210916225315806"></p>
<p>自旋能够充分提升多核cpu的效率，在java6后自旋锁是自适应的，比如对象刚刚一次自旋操作成功则认为这次自旋成功的可能性高，会多进行几次自旋；反之就少自旋甚至不自旋</p>
<p><strong>3.偏向锁</strong></p>
<p>轻量级锁在没有竞争时（本身线程），每次重入仍然需要执行 CAS 操作。<br>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现 这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p>
<pre><code class="java">static final Object obj = new Object();
public static void m1() &#123;
     synchronized( obj ) &#123;
         // 同步块 A
         m2();
     &#125;
&#125;
public static void m2() &#123;
     synchronized( obj ) &#123;
         // 同步块 B
         m3();
     &#125;
&#125;
public static void m3() &#123;
     synchronized( obj ) &#123;
          // 同步块 C
     &#125;
&#125;
</code></pre>
<p><img src="/2021/09/21/lock/image-20210916230912193.png" alt="image-20210916230912193"></p>
<p>使用偏向锁后就不需要CAS操作，直接判断线程ID</p>
<p><img src="/2021/09/21/lock/image-20210916230854627.png" alt="image-20210916230854627"></p>
<p>==偏向状态==</p>
<p>对象创建时：</p>
<ul>
<li>默认开启偏向锁，对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 thread、epoch、age 都为 0</li>
<li>偏向锁是默认是延迟的，不会在程序启动时立即生效，可以加VM参数==-XX:BiasedLockingStartupDelay=0==禁用延迟</li>
</ul>
<p>使用jol第三方工具读取markword的值，用于测试</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;
    &lt;artifactId&gt;jol-core&lt;/artifactId&gt;
    &lt;version&gt;0.16&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>1)延迟特性</p>
<p>2)偏向锁</p>
<pre><code class="java">public class TestBiased &#123;
    public static void main(String[] args) &#123;
        Lock lock = new Lock();
        new Thread(() -&gt; &#123;
            System.out.println(&quot;synchronized前&quot;);
            System.out.println(ClassLayout.parseInstance(lock).toPrintable());
            synchronized (lock) &#123;
                System.out.println(&quot;synchronized中&quot;);
                System.out.println(ClassLayout.parseInstance(lock).toPrintable());
            &#125;
            System.out.println(&quot;synchronized后&quot;);
            System.out.println(ClassLayout.parseInstance(lock).toPrintable());
        &#125;,&quot;t1&quot;).start();
    &#125;
&#125;
class Lock&#123;

&#125;
</code></pre>
<p><img src="/2021/09/21/lock/image-20210916232830431.png" alt="image-20210916232830431"></p>
<p>处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</p>
<p>3)禁用</p>
<p>通过添加VM参数-XX:-UseBiasedLocking禁用偏向锁</p>
<p><img src="/2021/09/21/lock/image-20210916233239252.png" alt="image-20210916233239252"></p>
<p>4)调用hashcode也会禁用偏向锁</p>
<p>正常状态对象一开始是没有 hashCode 的，第一次调用才生成，上述代码调用hashcode就会禁用偏向锁</p>
<p>原因：hashcode在markword占用31位，使用偏向锁后无法存入hashcode</p>
<blockquote>
<p>撤销-调用对象的hashCode</p>
</blockquote>
<p>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，没有多余的空间存储hashcode，如果调用 hashCode 会导致偏向锁被撤销，转而使用轻量锁</p>
<ul>
<li>轻量级锁会在锁记录中记录hashcode</li>
<li>重量级锁会在monitor中记录hashcode</li>
</ul>
<blockquote>
<p>撤销-其他线程对该对象加锁</p>
</blockquote>
<pre><code class="java">public class TestBiased2 &#123;
    public static void main(String[] args) &#123;
        Lock lock = new Lock();
        new Thread(() -&gt; &#123;
            synchronized (lock) &#123;
                System.out.println(ClassLayout.parseInstance(lock).toPrintable());//0101
            &#125;
            synchronized (TestBiased2.class) &#123;
                TestBiased2.class.notify();
            &#125;
        &#125;).start();
        new Thread(() -&gt; &#123;
            synchronized (TestBiased2.class) &#123;
                try &#123;
                    TestBiased2.class.wait();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                System.out.println(ClassLayout.parseInstance(lock).toPrintable());//0101
                synchronized (lock) &#123;
                    System.out.println(ClassLayout.parseInstance(lock).toPrintable());//0000,解除偏向锁
                &#125;
                System.out.println(ClassLayout.parseInstance(lock).toPrintable());//0001
            &#125;
        &#125;,&quot;t2&quot;).start();
    &#125;
&#125;
</code></pre>
<p><img src="/2021/09/21/lock/image-20210916234915082.png"></p>
<p>当有其它线程使用该对象对其加锁时，偏向锁会撤销变为轻量级锁</p>
<blockquote>
<p>撤销-调用wait/notify</p>
</blockquote>
<p>因为wait/notify使用时是在重量级锁下的，肯定会撤销偏向锁</p>
<p>==批量重偏向==</p>
<p>对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象 的 Thread ID，当撤销偏向锁阈值超过20次后JVM会认为目前的偏向状态是错误的，于是会在给这些对象加锁时重新偏向至加锁线程</p>
<pre><code class="java">public class TestBiased3 &#123;
    public static void main(String[] args) &#123;
        Vector&lt;Lock&gt; list = new Vector&lt;&gt;();
        new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 30; i++) &#123;//从i=0开始就偏向线程t1了,1000
                Lock lock = new Lock();
                System.out.println(i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable());
                list.add(lock);
                synchronized (lock) &#123;
                    System.out.println(i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable());
                &#125;
            &#125;
            synchronized (list) &#123;
                list.notify();
            &#125;
        &#125;, &quot;t1&quot;).start();

        new Thread(() -&gt; &#123;
            synchronized (list) &#123;
                try &#123;
                    list.wait();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            System.out.println(&quot;==========================&quot;);
            for (int i = 0; i &lt; 30; i++) &#123;//前19个都是将偏向锁依然偏向t1,第20个及以后改为偏向t2
                Lock lock = list.get(i);
                System.out.println(i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable());
                synchronized (lock) &#123;
                    System.out.println(i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable());
                &#125;
                System.out.println(i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable());
            &#125;
        &#125;, &quot;t2&quot;).start();
    &#125;
&#125;
</code></pre>
<p>线程t1加锁时处于偏向状态，偏向t1线程</p>
<p><img src="/2021/09/21/lock/image-20210917000118919.png" alt="image-20210917000118919"></p>
<p>当线程t2刚开始对该对象加锁时，对象的偏向状态依然是偏向线程t1的，此时t2线程对对象加锁为轻量级锁</p>
<p><img src="/2021/09/21/lock/image-20210917000458627.png" alt="image-20210917000458627"></p>
<p>当撤销锁达到20次时，会改变偏向状态</p>
<p><img src="/2021/09/21/lock/image-20210917000646372.png" alt="image-20210917000646372"></p>
<p>==批量撤销==</p>
<p>当撤销偏向锁阈值超过 40 次后，jvm 会这样认为确实偏向错了，此时该对象的使用竞争太激烈，根本就不该偏向。于是整个类的所有对象 都会变为不可偏向的，新建的对象也是不可偏向的</p>
<pre><code class="java">public class TestBiased4 &#123;
    static Thread t1, t2, t3;

    public static void main(String[] args) throws InterruptedException &#123;
        test4();
    &#125;
    private static void test4() throws InterruptedException &#123;
        Vector&lt;Lock&gt; list = new Vector&lt;&gt;();
        int loopNumber = 39;
        t1 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; loopNumber; i++) &#123;
                Lock lock = new Lock();
                list.add(lock);
                synchronized (lock) &#123;
                    System.out.println((i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable()));
                &#125;
            &#125;
            LockSupport.unpark(t2);
        &#125;, &quot;t1&quot;);
        t1.start();
        t2 = new Thread(() -&gt; &#123;
            LockSupport.park();
            System.out.println((&quot;================ &quot;));
            for (int i = 0; i &lt; loopNumber; i++) &#123;
                Lock lock = list.get(i);
                System.out.println((i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable()));
                synchronized (lock) &#123;
                    System.out.println((i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable()));
                &#125;
                System.out.println((i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable()));
            &#125;
            LockSupport.unpark(t3);
        &#125;, &quot;t2&quot;);
        t2.start();
        t3 = new Thread(()-&gt; &#123;
            LockSupport.park();
            System.out.println(&quot;=================&quot;);
            for (int i = 0; i &lt; loopNumber; i++) &#123;
                Lock lock = list.get(i);
                System.out.println((i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable()));
                synchronized (lock) &#123;
                    System.out.println((i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable()));
                &#125;
                System.out.println((i + &quot;\t&quot; + ClassLayout.parseInstance(lock).toPrintable()));
            &#125;
        &#125;, &quot;t3&quot;);
        t3.start();
        t3.join();
        System.out.println((ClassLayout.parseInstance(new Lock()).toPrintable()));
    &#125;
&#125;
</code></pre>
<p><img src="/2021/09/21/lock/image-20210917001758215.png" alt="image-20210917001758215"></p>
<p>update</p>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="3128633651@qq.com">MaoZH</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2021/09/21/lock/">http://example.com/2021/09/21/lock/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="http://example.com">MaoZH的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tag"></i><a href="/tags/%E9%94%81%E6%9C%BA%E5%88%B6/">锁机制</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">锁机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronized-%E8%BF%9B%E9%98%B6"><span class="toc-number">2.</span> <span class="toc-text">Synchronized 进阶</span></a></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="next" href="/2021/09/21/hello-world/">Hello World &gt;</a></div><div id="valine-comment"><style type="text/css">.night .v[data-class=v] a { color: #0F9FB4 !important; }
.night .v[data-class=v] a:hover { color: #216C73 !important; }
.night .v[data-class=v] li { list-style: inherit; }
.night .v[data-class=v] .vwrap { border: 1px solid #223441; border-radius: 0; }
.night .v[data-class=v] .vwrap:hover { box-shadow: 0 0 6px 1px #223441; }
.night .v[data-class=v] .vbtn { border-radius: 0; background: none; }
.night .v[data-class=v] .vlist .vcard .vh { border-bottom-color: #293D4E; }
.night .v[data-class=v] .vwrap .vheader .vinput { border-bottom-color: #223441; }
.night .v[data-class=v] .vwrap .vheader .vinput:focus { border-bottom-color: #339EB4; }
.night .v[data-class=v] code, .night .v[data-class=v] pre,.night .v[data-class=v] .vlist .vcard .vhead .vsys { background: #203240 !important; }
.night .v[data-class=v] code, .night .v[data-class=v] pre { color: #F0F0F0; font-size: 95%; }
.v[data-class=v] .vcards .vcard .vh {border-bottom-color: #223441; }
.night .v[data-class=v] .vcards .vcard .vcontent.expand:before {background: linear-gradient(180deg,rgba(38,57,73,.4),rgba(38,57,73,.9));}
.night .v[data-class=v] .vcards .vcard .vcontent.expand:after {background: rgba(38,57,73,.9)}
</style><div id="vcomment"></div><script src="//cdn.bootcdn.net/ajax/libs/valine/1.4.14/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'',
  appKey:'',
  lang: 'zh-cn',
  placeholder:'ヾﾉ≧∀≦)o Come on, say something...',
  avatar:'identicon',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></section><footer><p>Copyright © 2016 - 2021 <a href="/." rel="nofollow">MaoZH</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> MaoZH.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script></body></html>